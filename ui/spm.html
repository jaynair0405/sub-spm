<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SPM Insights Console</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <!-- Tom Select for searchable dropdowns -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/css/tom-select.css" />
    <style>
      :root {
        --brand: #0b3d91;
        --brand-soft: #eef3ff;
        --accent: #f0b429;
        --border: #d7ddec;
        --text: #1f2533;
        --muted: #5b6070;
        --card: #ffffff;
        --bg: #f5f7fb;
      }
      .summary-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 0.9rem;
      }
      .summary-table th {
        text-align: left;
        padding: 10px;
        background: #eef3ff;
        border-bottom: 1px solid var(--border);
        color: var(--brand);
        font-weight: 600;
      }
      .summary-table td {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border);
      }
      .summary-table .section-title {
        background: #f5f7fb;
        font-weight: 600;
      }
      .no-data {
        text-align: center;
        color: var(--muted);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        background: linear-gradient(135deg, var(--bg), #edf1fc);
        color: var(--text);
        min-height: 100vh;
      }
      .page-shell {
        max-width: 1100px;
        margin: 0 auto;
        padding: 20px 22px 40px;
      }
      header {
        background: var(--brand);
        color: #fff;
        padding: 20px 24px;
        border-radius: 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        box-shadow: 0 20px 45px rgba(11, 61, 145, 0.25);
      }
      header h1 {
        margin: 0;
        font-size: 1.8rem;
        letter-spacing: 0.01em;
      }
      header span {
        font-size: 0.95rem;
        opacity: 0.95;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        font-size: 0.85rem;
      }
      .content {
        margin-top: 24px;
      }
      .card {
        background: var(--card);
        border-radius: 16px;
        padding: 18px 20px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
        box-shadow: 0 15px 60px rgba(15, 27, 65, 0.08);
      }
      .card h2 {
        margin: 0 0 18px;
        font-size: 1.2rem;
        color: var(--brand);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
        gap: 18px;
        margin-bottom: 10px;
      }
      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.92rem;
        color: var(--muted);
      }
      input,
      select {
        font: inherit;
        padding: 11px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #fff;
        transition: border 0.15s ease, box-shadow 0.15s ease;
      }
      input:focus,
      select:focus {
        border-color: var(--brand);
        box-shadow: 0 0 0 3px rgba(11, 61, 145, 0.15);
        outline: none;
      }
      /* Tom Select custom styling to match app theme */
      .ts-wrapper.single .ts-control {
        font: inherit;
        padding: 8px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #fff;
        min-height: 44px;
      }
      .ts-wrapper.single .ts-control:focus,
      .ts-wrapper.single.focus .ts-control {
        border-color: var(--brand);
        box-shadow: 0 0 0 3px rgba(11, 61, 145, 0.15);
      }
      .ts-dropdown {
        border-radius: 12px;
        border: 1px solid var(--border);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      }
      .ts-dropdown .option.active {
        background: var(--brand-soft);
        color: var(--brand);
      }
      .ts-dropdown .option:hover {
        background: var(--brand-soft);
        color: var(--brand);
      }
      .upload-zone {
        position: relative;
        border: 2px dashed #b8c6e3;
        border-radius: 16px;
        padding: 24px;
        text-align: center;
        background: var(--brand-soft);
        transition: border-color 0.2s ease, background 0.2s ease;
        cursor: pointer;
      }
      .upload-zone.dragover {
        border-color: var(--brand);
        background: #dfebff;
      }
      .upload-zone h3 {
        margin: 6px 0 8px;
        font-size: 1.2rem;
        color: var(--brand);
      }
      .upload-zone p {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }
      .upload-zone button {
        margin-top: 16px;
      }
      .upload-zone input {
        position: absolute;
        inset: 0;
        opacity: 0;
        pointer-events: none;
      }
      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 16px;
      }
      button {
        font: inherit;
        border: none;
        border-radius: 14px;
        padding: 12px 20px;
        cursor: pointer;
        background: var(--brand);
        color: #fff;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px rgba(11, 61, 145, 0.2);
      }
      button.secondary {
        background: var(--accent);
        color: #1d1400;
        box-shadow: 0 12px 24px rgba(240, 180, 41, 0.35);
      }
      button:hover {
        transform: translateY(-1px);
      }
      .panels {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 22px;
      }
      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        font-weight: 600;
        color: var(--brand);
      }
      .table-wrapper {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: 16px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 420px;
      }
      th,
      td {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
        font-size: 0.9rem;
        text-align: left;
      }
      th {
        background: #f8faff;
        font-weight: 600;
        color: var(--muted);
      }
      tbody tr:last-child td {
        border-bottom: none;
      }
      #chart {
        width: 100%;
        height: 320px;
        cursor: crosshair;
      }
      .brakefeel-chart {
        width: 100%;
        height: 260px;
        border: 1px solid var(--border);
        border-radius: 12px;
      }
      .segment-charts {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .segment-chart {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 14px;
        background: #fdfdff;
      }
      .segment-title {
        font-size: 0.92rem;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--brand);
      }
      .segment-chart-inner {
        width: 100%;
        height: 220px;
      }
      .subtle {
        color: var(--muted);
        font-size: 0.85rem;
      }
      @media (max-width: 680px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
        .upload-zone {
          padding: 24px;
        }
      }
      .meta-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 24px 20px; /* Row gap 24px, Column gap 20px */
  margin-top: 10px;
}

.meta-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: relative;
}

/* Optional: Add a subtle divider line between rows on mobile if needed, 
   but clean spacing usually looks better */

.meta-label {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--muted);
  font-weight: 600;
}

.meta-value {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--brand);
  font-family: "Inter", monospace; /* Monospace numbers look technical and precise */
}

/* Specific styling for the header of this section to match PDF "Office of Sr DEE" feel */
.report-header-badge {
  background: var(--brand-soft);
  color: var(--brand);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 0.8rem;
  font-weight: 600;
}
/* Report Header Styles */
.report-print-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 5px;
  border-bottom: 3px double var(--brand); /* Double line for official look */
  margin-bottom: 20px;
  background: #fff;
}

.header-left {
  text-align: left;
}

.railway-title {
  font-weight: 800;
  font-size: 1.1rem;
  color: var(--brand);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  line-height: 1.2;
}

.division-title {
  font-weight: 600;
  font-size: 0.9rem;
  color: var(--text);
  text-transform: uppercase;
  margin-bottom: 4px;
}

.office-title {
  font-size: 0.85rem;
  color: var(--muted);
  font-weight: 500;
}

.header-center {
  flex-grow: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-placeholder {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: #f0f4ff; /* Light blue background for placeholder */
  border: 2px dashed var(--brand);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--brand);
  font-size: 0.8rem;
  text-align: center;
  font-weight: 600;
}

/* If you have a real logo, use this class on the IMG tag inside header-center */
.real-logo {
  height: 80px;
  width: auto;
}

.header-right {
  text-align: right;
}

.report-name {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--brand);
  margin-bottom: 6px;
  letter-spacing: -0.02em;
}

.analysis-meta {
  font-size: 0.9rem;
  color: var(--text);
}

.analysis-date {
  font-weight: 600;
  color: var(--text);
}

/* Loading Overlay */
.loading-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.9);
  z-index: 9999;
  justify-content: center;
  align-items: center;
  flex-direction: column;
  gap: 16px;
}
.loading-overlay.active {
  display: flex;
}
.loading-spinner {
  width: 50px;
  height: 50px;
  border: 4px solid var(--border);
  border-top-color: var(--brand);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}
.loading-text {
  font-size: 1rem;
  color: var(--brand);
  font-weight: 500;
}

/* PDF Export Button */
.btn-pdf {
  background: #28a745;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  display: none;
  gap: 6px;
  align-items: center;
}
.btn-pdf:hover {
  background: #218838;
}
.btn-pdf.visible {
  display: inline-flex;
}
/* CSV Export Button */
.btn-csv {
  background: #17a2b8;
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  display: none;
  gap: 6px;
  align-items: center;
  margin-left: 8px;
}
.btn-csv:hover {
  background: #138496;
}
.btn-csv.visible {
  display: inline-flex;
}
.back-btn {
  background: transparent;
  border: none;
  color: #e8e7ed;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  padding: 6px 10px;
  margin-right: 12px;
}

.back-btn:hover {
  text-decoration: underline;
}


/* Print footer - hidden on screen */
.print-footer {
  display: none;
}

/* Print specific adjustments */
@media print {
  body { background: white; }
  .page-shell { padding: 0; max-width: 100%; }
  .report-print-header { margin-top: 0; }
  /* Hide the Upload/Input section when printing */
  section.card:nth-of-type(1) { display: none !important; }
  header { display: none !important; } /* Hide the blue app header */
  .btn-pdf { display: none !important; }
  .loading-overlay { display: none !important; }

  /* Prevent page breaks inside cards, charts, and tables */
  .card {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Tables should not split across pages */
  .summary-table, table, .table-wrapper {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Individual chart containers */
  #chart, #brakeFeelChart, #railwayLine {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Segmented charts - each segment stays together */
  .segment-charts > div {
    page-break-inside: avoid;
    break-inside: avoid;
    margin-bottom: 10px;
  }

  /* Platform entry charts */
  #platformEntryCharts > div {
    page-break-inside: avoid;
    break-inside: avoid;
  }

  /* Allow page breaks between major sections */
  .card {
    page-break-after: auto;
  }

  /* Ensure headers stay with their content */
  h2, .panel-header {
    page-break-after: avoid;
    break-after: avoid;
  }

  /* Print footer - only visible when printing */
  .print-footer {
    display: flex !important;
    justify-content: space-between;
    font-size: 8pt;
    color: #666;
    margin-top: 30px;
    padding-top: 10px;
    border-top: 1px solid #ccc;
  }
}

/* Toast notification */
.toast {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: white;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 0.9rem;
  z-index: 9999;
  opacity: 0;
  transition: opacity 0.3s ease;
}
.toast.show {
  opacity: 1;
}
    </style>
  </head>
  <body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
      <div class="loading-spinner"></div>
      <div class="loading-text" id="loadingText">Processing SPM data...</div>
    </div>

    <!-- Toast notification -->
    <div id="toast" class="toast"></div>

    <div class="page-shell">
      <header>
        <div>
          

          <div class="badge">Central Railway • BB Divn-Suburban • SPM</div>
          <h1>Suburban Performance Monitor</h1>
          <span>Upload SPM runs, select staff, and review train performance visually.</span>
        </div>
        
        <div class="badge">BB TRSO - Digital Workplace</div>
        <button id="btnBack" class="back-btn">← Back to SPM Hub</button>
      </header>

      <main class="content">
        <section class="card">
          <h2>Upload Run & Assign Metadata</h2>
          <div
            class="upload-zone"
            id="uploadZone"
          >
            <input
              type="file"
              id="fileInput"
              accept=".csv,.xlsx,.xls"
            />
            <h3>Drop CSV/Excel file here</h3>
            <p>Supported formats: CSV, XLSX, XLS</p>
            <button type="button">Browse Files</button>
          </div>
          <p
            class="subtle"
            id="fileInfo"
          >
            No file selected yet.
          </p>

          <div class="grid">
            <label>
              Staff (Motorman)
              <select id="staffId">
                <option value="" selected>Loading staff list...</option>
              </select>
            </label>
            <label>
              Train Number
              <input
                type="text"
                id="trainNumber"
                placeholder="e.g., K40, PL201"
                style="text-transform: uppercase;"
                oninput="this.value = this.value.toUpperCase()"
              />
            </label>
            <label>
              From Station
              <input
                type="text"
                id="fromStation"
                placeholder="e.g., CSMT, VDLR, TNA (optional)"
                style="text-transform: uppercase;"
                oninput="this.value = this.value.toUpperCase()"
              />
            </label>
            <label>
              To Station
              <input
                type="text"
                id="toStation"
                placeholder="e.g., KYN, PNVL, TNA (optional)"
                style="text-transform: uppercase;"
                oninput="this.value = this.value.toUpperCase()"
              />
            </label>
            <label>
              Date of Working
              <input
                type="date"
                id="dateOfWorking"
              />
            </label>
            <label>
              Analysed By (CLI)
              <select id="analysedBy">
                <option value="" selected>Loading CLI list...</option>
              </select>
            </label>
            <label>
              Unit Number
              <input
                type="text"
                id="unitNumber"
                placeholder="e.g., 2231"
              />
              <small id="unitPreview" style="display:none; color:#0b3d91; font-weight:500; margin-top:4px;"></small>
            </label>
            <!-- Notes field hidden but kept for backend compatibility -->
            <input type="hidden" id="notes" value="" />
          </div>
          <div class="actions">
            <button type="button" id="processBtn">Process Run</button>
            <button
              type="button"
              class="secondary"
              id="clearBtn"
            >
              Reset Form
            </button>
            <button type="button" id="pdfBtn" class="btn-pdf">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="12" y1="18" x2="12" y2="12"></line>
                <line x1="9" y1="15" x2="15" y2="15"></line>
              </svg>
              Export PDF
            </button>
            <button type="button" id="exportCsvBtn" class="btn-csv">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
              </svg>
              Export Daily CSV
            </button>
          </div>
        </section>
<div id="pdfHeader" class="report-print-header" style="display: none;">
  
  <div class="header-left">
    <div class="railway-title">CENTRAL RAILWAY</div>
    <div class="division-title">MUMBAI DIVISION</div>
    <div class="office-title">OFFICE OF SR. DEE (TRO)</div>
  </div>

  <div class="header-center">
    <div class="logo-placeholder">
      Indian<br>Railways
    </div>
  </div>

  <div class="header-right">
    <div class="report-name">SPM ANALYSIS REPORT</div>
    <div class="analysis-meta">
      Date of Analysis: <span id="headerAnalysisDate" class="analysis-date">-</span>
    </div>
  </div>

</div>
       <section class="card" id="reportMetadata" style="display: none;">
  <div class="panel-header">
    <div style="display:flex; align-items:center; gap:12px;">
      <span>Analysis Report Summary</span>
      <!-- <span class="report-header-badge">CENTRAL RAILWAY • MUMBAI</span> -->
    </div>
    </div>

  <div class="meta-grid">
    <div class="meta-item">
      <span class="meta-label">Date of Working</span>
      <span class="meta-value" id="metaDate">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Train Service</span>
      <span class="meta-value" id="metaTrainInfo">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">LP / Staff Name</span>
      <span class="meta-value" id="metaStaff">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Nominated CLI</span>
      <span class="meta-value" id="metaCli">-</span>
    </div>

    <div class="meta-item">
      <span class="meta-label">Departure</span>
      <span class="meta-value" id="metaDepTime">--:--:--</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Arrival</span>
      <span class="meta-value" id="metaArrTime">--:--:--</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Total Distance</span>
      <span class="meta-value" id="metaDistance">- km</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Running Time</span>
      <span class="meta-value" id="metaRunTime">- min</span>
    </div>

    <div class="meta-item">
      <span class="meta-label">Route</span>
      <span class="meta-value" id="metaRoute">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Unit / Rake / Shed</span>
      <span class="meta-value" id="metaUnit">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Max Speed</span>
      <span class="meta-value" id="metaMaxSpeed">- km/h</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Analysed By</span>
      <span class="meta-value" id="metaAnalyst">-</span>
    </div>
  </div>
</section>

        <section class="card">
          <div class="panel-header">
            <span>Platform Entry Overview</span>
            <span class="subtle">Platform entry speeds • Green: ≤43 km/h • Red: >43 km/h</span>
          </div>
          <div style="width: 100%; height: 150px;">
            <svg id="railwayLine" style="width: 100%; height: 100%;"></svg>
          </div>
        </section>

        <section class="card">
          <div class="panel-header">
            <span>Speed Profile Chart</span>
            <span class="subtle">Distance vs Speed</span>
          </div>
          <div id="chart"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Segmented Speed Profiles</span>
            <span class="subtle">Same chart split into 4-5 station windows</span>
          </div>
          <div id="segmentCharts" class="segment-charts"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Platform Entry Analysis</span>
            <span class="subtle">Speed drop from PF entry to stop</span>
          </div>
          <div id="platformEntryCharts" class="segment-charts"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Trip Summary</span>
            <span class="subtle">Exceptions & observations</span>
          </div>
          <table class="summary-table" id="tripSummaryTable">
            <thead>
              <tr><th>Category</th><th>Details</th></tr>
            </thead>
            <tbody>
              <tr class="section-title"><td colspan="2">Platform Entry Speeds</td></tr>
              <tr>
                <td colspan="2">
                  <table class="summary-table">
                    <thead>
                      <tr>
                        <th>PF Entry > 42</th>
                        <th>Mid PF > 30</th>
                        <th>1 Coach > 15</th>
                      </tr>
                    </thead>
                    <tbody id="pfSummaryBody">
                      <tr><td colspan="3" class="no-data">No exceptions detected</td></tr>
                    </tbody>
                  </table>
                </td>
              </tr>
              <tr class="section-title"><td colspan="2">MPS/PSR Violations (PSR+3 Threshold)</td></tr>
              <tr>
                <td colspan="2">
                  <table class="summary-table">
                    <thead>
                      <tr>
                        <th>#</th>
                        <th>Time</th>
                        <th>Location (km)</th>
                        <th>Max Speed</th>
                        <th>Limit</th>
                        <th>Excess</th>
                        <th>Severity</th>
                      </tr>
                    </thead>
                    <tbody id="overspeedEventsBody">
                      <tr><td colspan="7" class="no-data">No overspeed events detected</td></tr>
                    </tbody>
                  </table>
                </td>
              </tr>
              <tr class="section-title"><td colspan="2">Brake Feel Test</td></tr>
              <tr><td>Train start time</td><td id="bftStartTime">-</td></tr>
              <tr><td>Test time</td><td id="bftTestTime">-</td></tr>
              <tr><td>Test speed</td><td id="bftTestSpeed">-</td></tr>
              <tr><td>Speed dropped to</td><td id="bftDropSpeed">-</td></tr>
              <tr><td>Observation</td><td id="bftObservation">No data</td></tr>
              <tr class="section-title"><td colspan="2">Abnormality Summary</td></tr>
              <tr><td colspan="2" id="abnormalityText" style="white-space: pre-line; font-weight: 500;">-</td></tr>
            </tbody>
          </table>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Brake Feel Test</span>
            <span class="subtle">Acceleration → braking → recovery window</span>
          </div>
          <div id="brakeFeelStatus" class="subtle" style="margin-bottom:8px;">Brake feel detection pending...</div>
          <div id="brakeFeelChart" class="brakefeel-chart"></div>
        </section>

        <!-- Print-only footer (appears on last page) -->
        <div class="print-footer">
          <span>@CR Sr.DEE TRSO-BB Division</span>
          <span>Developed by Jayakumar M D Mman Kyn</span>
        </div>
      </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/echarts@5"></script>
    <script src="https://cdn.jsdelivr.net/npm/tom-select@2.3.1/dist/js/tom-select.complete.min.js"></script>
    <script>
      const uploadZone = document.getElementById("uploadZone");
      const fileInput = document.getElementById("fileInput");
      const fileInfo = document.getElementById("fileInfo");
      const processBtn = document.getElementById("processBtn");
      const clearBtn = document.getElementById("clearBtn");

      const renderExceptionsTable = (markers = []) => {
        const tbody = document.getElementById("pfSummaryBody");
        if (!tbody) return;

        const pfEntries = [];
        const midEntries = [];
        const oneEntries = [];

        (markers || []).forEach((marker) => {
          if (marker.platform_entry_speed > 42) {
            pfEntries.push(`${marker.station} · ${marker.platform_entry_speed} km/h`);
          }
          if (marker.mid_platform_speed > 30) {
            midEntries.push(`${marker.station} · ${marker.mid_platform_speed} km/h`);
          }
          if (marker.one_coach_speed > 15) {
            oneEntries.push(`${marker.station} · ${marker.one_coach_speed} km/h`);
          }
        });

        const maxRows = Math.max(pfEntries.length, midEntries.length, oneEntries.length);
        if (maxRows === 0) {
          tbody.innerHTML = `<tr><td colspan="3" class="no-data">No exceptions detected</td></tr>`;
          return;
        }

        let rowsHtml = "";
        for (let i = 0; i < maxRows; i++) {
          rowsHtml += `
            <tr>
              <td>${pfEntries[i] ?? "-"}</td>
              <td>${midEntries[i] ?? "-"}</td>
              <td>${oneEntries[i] ?? "-"}</td>
            </tr>
          `;
        }
        tbody.innerHTML = rowsHtml;
      };

      const renderOverspeedEvents = (events = [], summary = {}) => {
        const tbody = document.getElementById("overspeedEventsBody");
        if (!tbody) return;

        if (!events || events.length === 0) {
          tbody.innerHTML = `<tr><td colspan="7" class="no-data">No overspeed events detected</td></tr>`;
          return;
        }

        const severityColors = {
          minor: '#FFA500',
          moderate: '#FF6B00',
          severe: '#FF0000',
          critical: '#8B0000'
        };

        let rowsHtml = "";
        events.forEach((event) => {
          const color = severityColors[event.severity] || '#FF0000';
          rowsHtml += `
            <tr>
              <td>${event.event_number}</td>
              <td>${event.start_time} - ${event.end_time}</td>
              <td>${event.start_km} - ${event.end_km}</td>
              <td style="font-weight:bold;">${event.max_speed} km/h</td>
              <td>${event.psr_value} km/h</td>
              <td style="color:${color}; font-weight:bold;">+${event.max_excess} km/h</td>
              <td style="color:${color}; text-transform:uppercase;">${event.severity}</td>
            </tr>
          `;
        });

        // Add summary row
        if (summary && summary.total_events > 0) {
          rowsHtml += `
            <tr style="background:#f5f5f5; font-weight:bold;">
              <td colspan="3">TOTAL: ${summary.total_events} events</td>
              <td>${summary.max_speed_overall} km/h</td>
              <td>-</td>
              <td>+${summary.max_excess_overall} km/h</td>
              <td>${summary.by_severity?.critical || 0}C / ${summary.by_severity?.severe || 0}S / ${summary.by_severity?.moderate || 0}M</td>
            </tr>
          `;
        }

        tbody.innerHTML = rowsHtml;
      };

      let chart = null;
      let segmentCharts = [];
      let platformEntryCharts = [];
      let brakeFeelChart = null;
      const brakeFeelStatusEl = document.getElementById("brakeFeelStatus");
      const tripSummaryTable = document.getElementById("tripSummaryTable");

      function initChart() {
        const chartEl = document.getElementById("chart");
        if (chartEl && !chart) {
          chart = echarts.init(chartEl);
        }
        return chart;
      }

      function disposeSegmentCharts() {
        segmentCharts.forEach((c) => c.dispose());
        segmentCharts = [];
        const container = document.getElementById("segmentCharts");
        if (container) {
          container.innerHTML = "";
        }
      }

      function disposePlatformEntryCharts() {
        platformEntryCharts.forEach((c) => c.dispose());
        platformEntryCharts = [];
        const container = document.getElementById("platformEntryCharts");
        if (container) {
          container.innerHTML = "";
        }
      }

      function disposeBrakeFeelChart() {
        if (brakeFeelChart) {
          brakeFeelChart.dispose();
          brakeFeelChart = null;
        }
        const container = document.getElementById("brakeFeelChart");
        if (container) {
          container.innerHTML = "";
        }
        if (brakeFeelStatusEl) {
          brakeFeelStatusEl.textContent = "Brake feel detection pending...";
        }
      }

      function buildStationGroups(markers, chunkSize = 5) {
        if (!markers || markers.length === 0) return [];

        const sorted = [...markers].sort(
          (a, b) => a.sample_index - b.sample_index
        );

        const groups = [];
        let i = 0;
        while (i < sorted.length) {
          const end = Math.min(i + chunkSize, sorted.length);
          let group = sorted.slice(i, end);

          if (group.length === 1 && groups.length > 0) {
            groups[groups.length - 1] =
              groups[groups.length - 1].concat(group);
          } else {
            groups.push(group);
          }

          if (group.length >= 2) {
            i += chunkSize - 1;
          } else {
            i = end;
          }
        }

        if (groups.length > 1 && groups[groups.length - 1].length === 1) {
          groups[groups.length - 2] = groups[groups.length - 2].concat(
            groups.pop()
          );
        }

        return groups.filter((group) => group.length >= 2);
      }

      function renderSegmentCharts(samples, markers, brakeTests = []) {
        disposeSegmentCharts();

        let workingMarkers = markers;
        if (!workingMarkers || workingMarkers.length < 2) {
          if (!samples || samples.length < 2) {
            return;
          }
          const syntheticCount = 4;
          const step = Math.floor(samples.length / syntheticCount);
          workingMarkers = [];
          for (let i = 0; i <= syntheticCount; i++) {
            const sampleIndex = Math.min(i * step, samples.length - 1);
            workingMarkers.push({
              station: i === 0 ? "Start" : i === syntheticCount ? "End" : `Segment ${i}`,
              sample_index: sampleIndex,
              platform_entry_speed: null,
              mid_platform_speed: null,
              one_coach_speed: null,
            });
          }
        }

        const stationGroups = buildStationGroups(workingMarkers);
        if (!stationGroups.length) {
          return;
        }

        const container = document.getElementById("segmentCharts");
        stationGroups.forEach((group, idx) => {
          const startIdx = Math.max(group[0].sample_index, 0);
          const endIdx = Math.min(
            group[group.length - 1].sample_index,
            samples.length - 1
          );
          const segmentSamples = samples.slice(startIdx, endIdx + 1);

          if (segmentSamples.length < 2) {
            return;
          }

          const chartWrapper = document.createElement("div");
          chartWrapper.className = "segment-chart";
          chartWrapper.id = `segment-chart-${idx}`;

          const title = document.createElement("div");
          title.className = "segment-title";
          const firstStation = group[0].station;
          const lastStation = group[group.length - 1].station;
          title.textContent = `${idx + 1}. ${firstStation} → ${lastStation}`;

          chartWrapper.appendChild(title);
          const chartDiv = document.createElement("div");
          chartDiv.className = "segment-chart-inner";
          chartWrapper.appendChild(chartDiv);
          container.appendChild(chartWrapper);

          const segmentChart = echarts.init(chartDiv);
          segmentCharts.push(segmentChart);

          // Check if distances are in meters and convert to km
          const segMaxDist = Math.max(...segmentSamples.map(s => s.cumulative_distance || 0));
          const segIsMeters = segMaxDist > 200;
          const segmentDistances = segmentSamples.map((s) => {
            const dist = s.cumulative_distance || 0;
            return segIsMeters ? (dist / 1000).toFixed(2) : dist.toFixed(2);
          });
          const segmentSpeeds = segmentSamples.map((s) => s.speed);
          const segmentPSR = segmentSamples.map((s) => s.psr || null);
          const hasPSR = segmentPSR.some((v) => v !== null);

          const markLines = group.map((marker) => ({
            xAxis: marker.sample_index - startIdx,
            label: {
              formatter: marker.station,
              position: "insideEndTop",
              fontSize: 9,
              color: "#333",
            },
            lineStyle: {
              color: "#999",
              type: "dashed",
            },
          }));

          const series = [];
          if (hasPSR) {
            series.push({
              name: "MPS/PSR",
              type: "line",
              data: segmentPSR,
              smooth: false,
              lineStyle: { color: "#00c800", width: 1 },
              areaStyle: { color: "rgba(0, 200, 0, 0.25)" },
              showSymbol: false,
              z: 1,
            });
          }

          series.push({
            name: "Speed",
            type: "line",
            data: segmentSpeeds,
            smooth: false,
            lineStyle: { color: "#007bff", width: 2 },
            areaStyle: { color: "rgba(0, 123, 255, 0.1)" },
            symbol: "circle",
            symbolSize: 4,
            z: 2,
            markLine: markLines.length
              ? {
                  data: markLines,
                }
              : undefined,
          });

          const segmentBrakeAreas = (brakeTests || [])
            .filter(
              (test) =>
                test.end_index >= startIdx &&
                test.start_index <= endIdx
            )
            .map((test) => {
              const clampedStart = Math.max(test.start_index - startIdx, 0);
              const clampedEnd = Math.min(
                test.end_index - startIdx,
                segmentSamples.length - 1
              );
              return [
                {
                  xAxis: clampedStart,
                  itemStyle: { color: "rgba(255,0,0,0.08)" },
                },
                { xAxis: clampedEnd },
              ];
            });

          if (segmentBrakeAreas.length) {
            series.push({
              name: "Brake Feel Test",
              type: "line",
              data: [],
              markArea: {
                silent: true,
                data: segmentBrakeAreas,
              },
            });
          }

          segmentChart.setOption({
            tooltip: { trigger: "axis" },
            legend: {
              data: hasPSR
                ? ["Speed", "MPS/PSR", "Brake Feel Test"]
                : ["Speed", "Brake Feel Test"],
            },
            grid: {
              left: "3%",
              right: "4%",
              bottom: "8%",
              containLabel: true,
            },
            xAxis: {
              type: "category",
              data: segmentDistances,
              axisLabel: { fontSize: 9 },
            },
            yAxis: {
              type: "value",
              name: "Speed (km/h)",
              nameLocation: "middle",
              nameGap: 35,
              axisLabel: { fontSize: 9 },
            },
            series,
          });
        });
      }

      function renderPlatformEntryCharts(samples, markers, platformEntryData) {
        disposePlatformEntryCharts();

        if (!markers || !platformEntryData) {
          return;
        }

        // Filter markers to only include stations with platform entry data
        const validMarkers = markers.filter(m =>
          m.platform_entry_speed !== null &&
          m.platform_entry_speed !== 0 &&
          platformEntryData[m.station]
        );

        if (validMarkers.length === 0) {
          return;
        }

        const container = document.getElementById("platformEntryCharts");

        // Check if samples are in meters or km
        const maxDistance = Math.max(...samples.map(s => s.cumulative_distance));
        const sampleInMeters = maxDistance > 100;

        const stationsToRender = validMarkers;  // All halts
        const colors = ['#4285f4', '#ea4335', '#fbbc05', '#34a853', '#9c27b0', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7'];
        const stationSeries = [];

        stationsToRender.forEach((marker, idx) => {
          const stationName = marker.station;
          const entryData = platformEntryData[stationName];

          if (!entryData) return;

          const haltDistanceKm = entryData.halt_distance;
          const entryDistanceKm = entryData.entry_distance;

          // Convert to same units as samples
          const haltDistance = sampleInMeters ? haltDistanceKm * 1000 : haltDistanceKm;
          const entryDistance = sampleInMeters ? entryDistanceKm * 1000 : entryDistanceKm;

          // Find all samples between entry and halt
          const stationSamples = samples.filter(s => {
            const dist = s.cumulative_distance;
            return dist >= entryDistance && dist <= haltDistance;
          });

          if (stationSamples.length < 2) return;

          // Prepare data for this station
          const dataPoints = [];

          for (let s of stationSamples) {
            const distFromHalt = haltDistance - s.cumulative_distance;
            if (distFromHalt < 0) break;

            const distFromHaltMeters = sampleInMeters ? distFromHalt : distFromHalt * 1000;
            dataPoints.push([Math.round(distFromHaltMeters), s.speed]);

            // Don't break at speed=0 - continue to actual halt position
            // Signal stops before platform should still show in chart
          }

          if (dataPoints.length > 0) {
            stationSeries.push({
              name: stationName,
              data: dataPoints,
              color: colors[idx % colors.length]
            });
          }
        });

        if (stationSeries.length === 0) return;

        const linesPerChart = 5;
        let groupCounter = 0;

        for (let start = 0; start < stationSeries.length; start += linesPerChart) {
          const groupSeries = stationSeries.slice(start, start + linesPerChart).map(series => ({
            name: series.name,
            type: 'line',
            data: series.data.map(point => [...point]),
            smooth: 0.4,
            lineStyle: { color: series.color, width: 3 },
            symbol: 'circle',
            symbolSize: 0,
            showSymbol: false
          }));

          if (!groupSeries.length) continue;

          groupSeries[0].markLine = {
            silent: true,
            symbol: 'none',
            label: {
              position: 'end',
              formatter: '{b}',
              fontSize: 9
            },
            lineStyle: {
              type: 'dashed',
              color: '#999',
              width: 1
            },
            data: [
              { xAxis: 130, name: '130m' },
              { xAxis: 20, name: '20m' }
            ]
          };

          const chartWrapper = document.createElement("div");
          chartWrapper.className = "segment-chart";

          const title = document.createElement("div");
          title.className = "segment-title";
          groupCounter += 1;
          title.textContent = `Speed vs Distance - Group ${groupCounter}`;

          chartWrapper.appendChild(title);
          const chartDiv = document.createElement("div");
          chartDiv.className = "segment-chart-inner";
          chartWrapper.appendChild(chartDiv);
          container.appendChild(chartWrapper);

          const platformChart = echarts.init(chartDiv);
          platformEntryCharts.push(platformChart);

          platformChart.setOption({
            tooltip: {
              trigger: 'axis',
              formatter: function(params) {
                if (!params || params.length === 0) return '';
                const dist = params[0].value[0];
                let result = `Distance: ${dist}m from halt<br/>`;
                params.forEach(p => {
                  if (p.value && p.value[1] !== null) {
                    result += `${p.seriesName}: ${p.value[1].toFixed(1)} km/h<br/>`;
                  }
                });
                return result;
              }
            },
            legend: {
              data: groupSeries.map(s => s.name),
              top: 5,
              textStyle: { fontSize: 9 }
            },
            grid: {
              left: '8%',
              right: '3%',
              bottom: '15%',
              top: '15%',
              containLabel: true
            },
            xAxis: {
              type: 'value',
              name: 'Distance',
              nameLocation: 'middle',
              nameGap: 25,
              inverse: true,
              splitNumber: 10,
              minInterval: 1,
              axisLabel: {
                fontSize: 9,
                formatter: function(value) {
                  if (value === 0) return 'Halt';
                  if (value === 20) return '20m';
                  if (value === 130) return '130m';
                  return value + 'm';
                }
              }
            },
            yAxis: {
              type: 'value',
              name: 'Speed',
              nameLocation: 'middle',
              nameGap: 35,
              min: 0,
              max: 50,
              axisLabel: { fontSize: 9 }
            },
            series: groupSeries
          });
        }
      }

      function renderBrakeFeelChart(samples, brakeTests, firstHaltIndex) {
        const container = document.getElementById("brakeFeelChart");
        if (!container) {
          return;
        }

        if (!samples || samples.length === 0) {
          disposeBrakeFeelChart();
          if (brakeFeelStatusEl) {
            brakeFeelStatusEl.textContent = "No run data available";
          }
          return;
        }

        // Limit to first segment only (start to first halt)
        // Use firstHaltIndex if available, otherwise use ~25% of samples or max 500 points
        let endIdx = samples.length;
        if (firstHaltIndex && firstHaltIndex > 0) {
          endIdx = Math.min(firstHaltIndex + 50, samples.length); // Include some buffer after first halt
        } else {
          endIdx = Math.min(Math.floor(samples.length * 0.25), 500);
        }
        const segmentSamples = samples.slice(0, endIdx);

        if (!brakeFeelChart) {
          brakeFeelChart = echarts.init(container);
        }

        const distances = segmentSamples.map((s, idx) => {
          const value =
            s.cumulative_distance !== undefined && s.cumulative_distance !== null
              ? s.cumulative_distance
              : s.distance !== undefined && s.distance !== null
              ? s.distance
              : idx;
          return Number(value);
        });
        // Check if distances are in meters and convert to km
        const bfMaxDist = Math.max(...distances);
        const bfIsMeters = bfMaxDist > 200;
        const distanceLabels = distances.map((d) =>
          Number.isFinite(d) ? (bfIsMeters ? (d / 1000).toFixed(2) : d.toFixed(2)) : "0.00"
        );
        const speeds = segmentSamples.map((s) => s.speed ?? 0);

        const markAreas = (brakeTests || [])
          .map((test) => {
            if (test.start_index === undefined || test.end_index === undefined) {
              return null;
            }
            const startIdx = Math.max(
              0,
              Math.min(test.start_index, distanceLabels.length - 1)
            );
            const endIdx = Math.max(
              startIdx + 1,
              Math.min(test.end_index, distanceLabels.length - 1)
            );
            return [
              {
                xAxis: distanceLabels[startIdx],
                itemStyle: { color: "rgba(255, 0, 0, 0.1)" },
                label: {
                  show: true,
                  formatter: "BFT",
                  color: "#c00",
                },
              },
              { xAxis: distanceLabels[endIdx] },
            ];
          })
          .filter(Boolean);

        if (brakeFeelStatusEl) {
          brakeFeelStatusEl.textContent =
            brakeTests && brakeTests.length
              ? "Brake feel test detected"
              : "No brake feel test detected";
        }

        brakeFeelChart.setOption({
          tooltip: { trigger: "axis" },
          legend: {
            data: markAreas.length ? ["Speed", "Brake Feel Test"] : ["Speed"],
          },
          grid: { left: 45, right: 20, top: 35, bottom: 40 },
          xAxis: {
            type: "category",
            data: distanceLabels,
            name: "Cumulative Distance (km)",
            nameLocation: "middle",
            nameGap: 30,
            axisLabel: { fontSize: 9 },
          },
          yAxis: {
            type: "value",
            name: "Speed (km/h)",
            nameLocation: "middle",
            nameGap: 35,
            axisLabel: { fontSize: 9 },
          },
          series: [
            {
              name: "Speed",
              type: "line",
              data: speeds,
              smooth: true,
              lineStyle: { color: "#0b3d91", width: 2 },
              showSymbol: false,
              markArea: markAreas.length
                ? {
                    silent: true,
                    data: markAreas,
                  }
                : undefined,
            },
          ],
        });
      }

      function renderTripSummary(stationMarkers, brakeTests, samples) {
        renderExceptionsTable(stationMarkers || []);

        const startCell = document.getElementById("bftStartTime");
        const testTimeCell = document.getElementById("bftTestTime");
        const testSpeedCell = document.getElementById("bftTestSpeed");
        const dropSpeedCell = document.getElementById("bftDropSpeed");
        const observationCell = document.getElementById("bftObservation");

        if (!startCell || !testTimeCell || !testSpeedCell || !dropSpeedCell || !observationCell) {
          return;
        }

        if (brakeTests && brakeTests.length) {
          const test = brakeTests[0];
          const startSample = samples[test.max_speed_index] || samples[test.braking_start_index] || {};
          const recoverySample = samples[test.recovery_index] || {};

          startCell.textContent = samples[0]?.timestamp ?? "-";
          testTimeCell.textContent = startSample.timestamp ?? "-";
          testSpeedCell.textContent = test.braking_start_speed != null ? `${test.braking_start_speed} km/h` : "-";
          dropSpeedCell.textContent = test.lowest_speed != null ? `${test.lowest_speed} km/h` : "-";
          observationCell.textContent = "Brake feel test detected";
        } else {
          startCell.textContent = samples[0]?.timestamp ?? "-";
          testTimeCell.textContent = "-";
          testSpeedCell.textContent = "-";
          dropSpeedCell.textContent = "-";
          observationCell.textContent = "No brake feel test detected";
        }
      }
      // ╔════════════════════════════════════════════════════════════════════╗
      // ║  IMPORTANT: API BASE CONFIGURATION - CHANGE BEFORE DEPLOYMENT!      ║
      // ╠════════════════════════════════════════════════════════════════════╣
      // ║  FOR SERVER (crtms.in):  const CHART_API_BASE = "/spm/sub-spm";     ║
      // ║  FOR LOCAL DEVELOPMENT:  const CHART_API_BASE = "";                 ║
      // ╚════════════════════════════════════════════════════════════════════╝

      // >>> CURRENT SETTING: LOCAL DEVELOPMENT <<<
      //const CHART_API_BASE = "/spm/sub-spm";  // USE THIS FOR SERVER
      const CHART_API_BASE = "";                // USE THIS FOR LOCAL
      let currentRunId = null;
      let staffData = {}; // Store staff data for nominated CLI lookup
      let staffSelect = null; // Tom Select instance for staff dropdown

      // Loading overlay helpers
      function showLoading(message = "Processing SPM data...") {
        const overlay = document.getElementById("loadingOverlay");
        const textEl = document.getElementById("loadingText");
        if (textEl) textEl.textContent = message;
        if (overlay) overlay.classList.add("active");
      }

      function hideLoading() {
        const overlay = document.getElementById("loadingOverlay");
        if (overlay) overlay.classList.remove("active");
      }

      // PDF Export function
      function exportPDF() {
        // Show PDF header before printing
        document.getElementById("pdfHeader").style.display = "flex";
        // Trigger browser print dialog (user can save as PDF)
        window.print();
      }

      // Show/hide PDF button
      function showPdfButton() {
        const btn = document.getElementById("pdfBtn");
        if (btn) btn.classList.add("visible");
      }

      function hidePdfButton() {
        const btn = document.getElementById("pdfBtn");
        if (btn) btn.classList.remove("visible");
      }

      // Toast notification
      function showToast(message, duration = 4000) {
        const toast = document.getElementById("toast");
        toast.textContent = message;
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), duration);
      }

      // CSV Export functions
      function showCsvButton() {
        const btn = document.getElementById("exportCsvBtn");
        if (btn) btn.classList.add("visible");
      }

      function hideCsvButton() {
        const btn = document.getElementById("exportCsvBtn");
        if (btn) btn.classList.remove("visible");
      }

      function exportDailyCsv() {
        // Get today's date in YYYY-MM-DD format
        const today = new Date().toISOString().split('T')[0];
        // Open the CSV download in a new tab/window
        window.open(`${CHART_API_BASE}/api/export-daily-csv?date=${today}`, '_blank');
      }

      // Add click handler for CSV export button
      document.getElementById("exportCsvBtn")?.addEventListener("click", exportDailyCsv);

      // Sheds data cache
      let shedsData = null;

      // Load sheds data
      async function loadShedsData() {
        try {
          const response = await fetch(`${CHART_API_BASE}/reference_data/sheds.json`);
          if (response.ok) {
            shedsData = await response.json();
          }
        } catch (err) {
          console.error("Error loading sheds data:", err);
        }
      }

      // Get rake type from unit number
      function getRakeType(unitNumber) {
        const num = parseInt(unitNumber, 10);
        if (isNaN(num)) return null;

        if (num >= 240000 && num <= 249999) return "Alstom";
        if (num >= 8000 && num <= 8099) return "Medha U/S";
        if ((num >= 1000 && num <= 2999) ||
            (num >= 10000 && num <= 23999) ||
            (num >= 25000 && num <= 29999)) return "Siemens";
        if (num >= 4000 && num <= 4999) return "AC Retro";
        if (num >= 5000 && num <= 5999) return "Bombardier";
        if (num >= 6000 && num <= 6999) return "Medha";
        if (num >= 7000 && num <= 7999) return "AC BHEL";
        return null;
      }

      // Get shed from unit number by searching sheds data
      function getShedFromUnit(unitNumber) {
        if (!shedsData || !unitNumber) return null;
        const unitStr = unitNumber.toString().trim();

        for (const [shedName, rakeTypes] of Object.entries(shedsData)) {
          for (const [rakeType, rakes] of Object.entries(rakeTypes)) {
            for (const rake of rakes) {
              const coaches = rake.split('-');
              if (coaches.includes(unitStr)) {
                return shedName;
              }
            }
          }
        }
        return null;
      }

      // Get combined Unit/Rake/Shed string
      function getUnitRakeShedString(unitNumber) {
        if (!unitNumber) return "-";
        const rakeType = getRakeType(unitNumber) || "Unknown";
        const shed = getShedFromUnit(unitNumber) || "Unknown";
        return `${unitNumber}/${rakeType}/${shed}`;
      }

      // Get train service type (Slow/Fast) from train number
      function getTrainService(trainNumber) {
        if (!trainNumber) return "Unknown";
        const numStr = trainNumber.toString().trim();

        // 95xxx = Fast, everything else = Slow
        if (numStr.startsWith("95")) {
          return "Fast";
        }
        // 96xxx, 97xxx = Slow (Main line locals)
        // 98xxx = Harbour (all local/slow)
        // 99xxx = THB Trans-Harbour (all local/slow)
        return "Slow";
      }

      // Handle unit number input change
      function onUnitNumberChange() {
        const unitNumber = document.getElementById("unitNumber").value.trim();
        const rakeType = getRakeType(unitNumber);
        const shed = getShedFromUnit(unitNumber);

        // Update preview if needed (optional - can show in a helper text)
        const previewEl = document.getElementById("unitPreview");
        if (previewEl) {
          if (unitNumber && (rakeType || shed)) {
            previewEl.textContent = `${rakeType || '?'} / ${shed || '?'}`;
            previewEl.style.display = "block";
          } else {
            previewEl.style.display = "none";
          }
        }
      }

      // Load staff list from API
      async function loadStaffList() {
        try {
          const response = await fetch(`${CHART_API_BASE}/api/staff`);
          if (!response.ok) throw new Error("Failed to load staff list");
          const data = await response.json();

          const select = document.getElementById("staffId");
          select.innerHTML = '<option value="">-- Select Motorman --</option>';

          data.staff.forEach(staff => {
            const option = document.createElement("option");
            option.value = staff.hrms_id;
            option.textContent = `${staff.staff_name} - ${staff.cms_id}`;
            option.dataset.cmsId = staff.cms_id || "";
            option.dataset.nominatedCliId = staff.nominated_cli_id || "";
            select.appendChild(option);
            // Store for later lookup
            staffData[staff.hrms_id] = staff;
          });

          // Initialize Tom Select for searchable dropdown
          if (staffSelect) {
            staffSelect.destroy();
          }
          staffSelect = new TomSelect(select, {
            placeholder: "Type to search motorman...",
            allowEmptyOption: true,
            create: false,
            maxItems: 1,              // Single selection only
            selectOnTab: true,        // Tab key selects highlighted item
            closeAfterSelect: true,   // Close dropdown after selection
            sortField: { field: "text", direction: "asc" },
            render: {
              no_results: function() {
                return '<div class="no-results">No motorman found</div>';
              }
            }
          });
        } catch (err) {
          console.error("Error loading staff:", err);
          document.getElementById("staffId").innerHTML = '<option value="">Error loading staff</option>';
        }
      }

      // Load CLI list from API
      async function loadCliList() {
        try {
          const response = await fetch(`${CHART_API_BASE}/api/cli`);
          if (!response.ok) throw new Error("Failed to load CLI list");
          const data = await response.json();

          const select = document.getElementById("analysedBy");
          select.innerHTML = '<option value="">-- Select CLI --</option>';

          data.cli.forEach(cli => {
            const option = document.createElement("option");
            option.value = cli.cms_id || cli.cli_id;
            option.textContent = cli.cli_name;
            option.dataset.cliId = cli.cli_id;
            select.appendChild(option);
          });
        } catch (err) {
          console.error("Error loading CLI:", err);
          document.getElementById("analysedBy").innerHTML = '<option value="">Error loading CLI</option>';
        }
      }

      // Handle staff selection - auto-populate nominated CLI in metadata
      function onStaffSelect() {
        const hrmsId = document.getElementById("staffId").value;
        if (hrmsId && staffData[hrmsId]) {
          const staff = staffData[hrmsId];
          // Store nominated CLI info for later use in metadata display
          window.selectedStaffNominatedCliId = staff.nominated_cli_id;
        }
      }

      // Train number lookup - auto-fill From/To stations
      let trainLookupTimer = null;
      async function lookupTrainNumber(trainNumber) {
        if (!trainNumber || trainNumber.length < 2) return;
        try {
          const response = await fetch(`${CHART_API_BASE}/api/train_lookup/${encodeURIComponent(trainNumber)}`);
          if (!response.ok) return;
          const data = await response.json();
          if (data.found) {
            // Auto-fill From and To stations (always update on train number change)
            const fromField = document.getElementById("fromStation");
            const toField = document.getElementById("toStation");
            if (data.from_station) {
              fromField.value = data.from_station;
            }
            if (data.to_station) {
              toField.value = data.to_station;
            }
            console.log(`[Train Lookup] ${trainNumber}: ${data.from_station} → ${data.to_station} (${data.type_name})`);
          }
        } catch (err) {
          console.error("Train lookup error:", err);
        }
      }

      function onTrainNumberChange(e) {
        const value = e.target.value.trim();
        // Clear existing timer
        if (trainLookupTimer) clearTimeout(trainLookupTimer);
        // Debounce: wait 500ms after user stops typing
        trainLookupTimer = setTimeout(() => {
          lookupTrainNumber(value);
        }, 500);
      }

      // Initialize dropdowns on page load
      document.addEventListener("DOMContentLoaded", () => {
        loadStaffList();
        loadCliList();
        loadShedsData();
        document.getElementById("staffId").addEventListener("change", onStaffSelect);
        document.getElementById("unitNumber").addEventListener("input", onUnitNumberChange);
        document.getElementById("trainNumber").addEventListener("input", onTrainNumberChange);
      });

      async function uploadFile() {
        const file = fileInput.files[0];
        if (!file) {
          alert("Please select a file first");
          return null;
        }
        disposeSegmentCharts();
        disposePlatformEntryCharts();
        disposeBrakeFeelChart();

        const formData = new FormData();
        formData.append("file", file);
        formData.append("staff_id", document.getElementById("staffId").value);
        formData.append("from_station", document.getElementById("fromStation").value);
        formData.append("to_station", document.getElementById("toStation").value);
        formData.append("train_number", document.getElementById("trainNumber").value);
        formData.append("date_of_working", document.getElementById("dateOfWorking").value);
        formData.append("analysed_by", document.getElementById("analysedBy").value);
        formData.append("unit_number", document.getElementById("unitNumber").value);
        formData.append("notes", document.getElementById("notes").value);

        try {
          const response = await fetch(`${CHART_API_BASE}/upload`, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            const errorText = await response.text();
            alert(`Upload error: ${errorText}`);
            return null;
          }

          const result = await response.json();
          return result;
        } catch (err) {
          console.error(err);
          alert("Upload failed: " + err.message);
          return null;
        }
      }

      function createRailwayLine(stationData) {
        if (!stationData || stationData.length === 0) {
          // Clear the SVG if no data
          const svg = document.getElementById('railwayLine');
          svg.innerHTML = '';
          return;
        }

        // Fixed width to fit in one view - no scrolling!
        const width = 1050;
        const height = 150;
        const padding = 30;
        const lineY = height / 2;
        const SPEED_THRESHOLD = 43; // Green ≤ 43, Red > 43

        // Get max distance for scaling
        const maxDistance = Math.max(...stationData.map(s => s.distance));

        // Set up SVG
        const svg = document.getElementById('railwayLine');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.maxWidth = '100%';

        // Clear existing content
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }

        // Create main railway line
        const mainLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        mainLine.setAttribute('x1', padding);
        mainLine.setAttribute('y1', lineY);
        mainLine.setAttribute('x2', width - padding);
        mainLine.setAttribute('y2', lineY);
        mainLine.setAttribute('stroke', '#333');
        mainLine.setAttribute('stroke-width', '2.5');
        svg.appendChild(mainLine);

        // Function to calculate x position based on distance
        function getXPosition(distance) {
          return (distance / maxDistance) * (width - 2 * padding) + padding;
        }

        // Add stations
        stationData.forEach((station, index) => {
          const xPos = getXPosition(station.distance);

          // Create station circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', xPos);
          circle.setAttribute('cy', lineY);
          circle.setAttribute('r', 6);

          // Color based on speed
          if (station.speed <= SPEED_THRESHOLD) {
            circle.setAttribute('fill', '#00cc00'); // Green
            circle.setAttribute('stroke', '#009900');
          } else {
            circle.setAttribute('fill', '#ff0000'); // Red
            circle.setAttribute('stroke', '#cc0000');
          }
          circle.setAttribute('stroke-width', '1.5');
          svg.appendChild(circle);

          // Station name (alternating above/below)
          const stationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          stationText.textContent = station.station.replace('Entry', '').trim();
          stationText.setAttribute('x', xPos);
          stationText.setAttribute('y', index % 2 === 0 ? lineY - 20 : lineY + 32);
          stationText.setAttribute('text-anchor', 'middle');
          stationText.setAttribute('font-size', '10px');
          stationText.setAttribute('font-family', 'Inter, Arial, sans-serif');
          stationText.setAttribute('font-weight', '600');
          stationText.setAttribute('fill', '#0b3d91');
          svg.appendChild(stationText);

          // Speed label (alternating above/below) - just the number
          const speedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          speedText.textContent = station.speed.toFixed(0);
          speedText.setAttribute('x', xPos);
          speedText.setAttribute('y', index % 2 === 0 ? lineY - 8 : lineY + 44);
          speedText.setAttribute('text-anchor', 'middle');
          speedText.setAttribute('font-size', '10px');
          speedText.setAttribute('font-family', 'Inter, Arial, sans-serif');
          speedText.setAttribute('font-weight', 'bold');
          speedText.setAttribute('fill', station.speed <= SPEED_THRESHOLD ? '#00aa00' : '#cc0000');
          svg.appendChild(speedText);
        });
      }

      async function loadChartData(runId = null) {
        try {
          const body = runId ? { run_id: runId } : {};
          const response = await fetch(`${CHART_API_BASE}/chart_data`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!response.ok) {
            const errorText = await response.text();
            alert(`Chart data error: ${errorText}`);
            return;
          }

          const payload = await response.json();

          const samples = payload.samples ?? [];
          const brakeTests = payload.brake_tests ?? [];

          disposeSegmentCharts();
          disposePlatformEntryCharts();

          // Create railway line diagram from station halt data
          if (payload.station_markers && payload.station_markers.length > 0) {
            // Extract platform entry speeds for railway line
            const stationHaltData = payload.station_markers.map(marker => {
              // Use platform entry speed if available, otherwise fallback to halt speed
              const sample = samples[marker.sample_index];
              const speed = marker.platform_entry_speed !== null && marker.platform_entry_speed !== undefined
                ? marker.platform_entry_speed
                : (sample ? sample.speed : 0);

              return {
                station: marker.station,
                distance: sample ? sample.cumulative_distance : 0,
                speed: speed
              };
            }).filter(s => s.distance >= 0); // Include start station at 0 distance

            createRailwayLine(stationHaltData);
          } else {
            // Clear railway line if no station data
            createRailwayLine([]);
          }

          // Update table with station halt data showing platform entry speeds
          // Filter out starting stations (where platform_entry_speed is 0 or null)
          renderExceptionsTable(payload.station_markers || []);

          // Render overspeed events table (from chart_data for historical runs)
          renderOverspeedEvents(payload.overspeed_events || [], payload.overspeed_summary || {});

          // Update chart with all data
          // Check if distances are in meters (max > 200) and convert to km for display
          const maxDist = Math.max(...samples.map(s => s.cumulative_distance || s.distance || 0));
          const isMeters = maxDist > 200;
          const distances = samples.map((s) => {
            const dist = s.cumulative_distance || s.distance || 0;
            return isMeters ? (dist / 1000).toFixed(2) : dist.toFixed(2);
          });
          const speeds = samples.map((s) => s.speed);
          const psrValues = samples.map((s) => s.psr || null);

          // Check if PSR data is available
          const hasPSR = psrValues.some(v => v !== null);

          const chartInstance = initChart();
          if (!chartInstance) {
            console.error("Failed to initialize chart");
            return;
          }

          // Build series array
          const series = [];

          // Add PSR/MPS series first (so it appears behind the speed line)
          if (hasPSR) {
            series.push({
              name: 'MPS/PSR',
              type: 'line',
              data: psrValues,
              smooth: false,
              lineStyle: { color: '#00c800', width: 1 },
              areaStyle: { color: 'rgba(0, 200, 0, 0.25)' },
              showSymbol: false,
              z: 1,  // Draw behind speed line
            });
          }

          // Prepare station markers (vertical dashed lines with station names)
          const stationMarkLines = [];
          if (payload.station_markers && payload.station_markers.length > 0) {
            payload.station_markers.forEach(marker => {
              stationMarkLines.push({
                xAxis: marker.sample_index,
                label: {
                  formatter: marker.station,
                  position: 'insideEndTop',
                  fontSize: 10,
                  color: '#333',
                  backgroundColor: 'rgba(255, 255, 255, 0.9)',
                  padding: [2, 4],
                  borderRadius: 3
                },
                lineStyle: {
                  color: '#888',
                  type: 'dashed',
                  width: 1
                }
              });
            });
          }

          // Add actual speed series with station markers
          series.push({
            name: 'Actual Speed',
            type: 'line',
            data: speeds,
            smooth: true,
            lineStyle: { color: '#0b3d91', width: 2 },
            showSymbol: false,
            z: 2,  // Draw on top
            markLine: stationMarkLines.length ? {
              symbol: 'none',
              data: stationMarkLines
            } : undefined
          });

          // Add brake feel areas
          const brakeAreas = brakeTests
            .map((test) => {
              const startIdx = Math.max(test.start_index, 0);
              const endIdx = Math.min(test.end_index, distances.length - 1);
              if (endIdx <= startIdx) return null;
              return [
                {
                  xAxis: distances[startIdx],
                  itemStyle: { color: "rgba(255, 0, 0, 0.1)" },
                  name: "BFT",
                },
                { xAxis: distances[endIdx] },
              ];
            })
            .filter(Boolean);

          if (brakeAreas.length) {
            series.push({
              name: "Brake Feel Test",
              type: "line",
              data: [],
              markArea: {
                silent: true,
                data: brakeAreas,
              },
            });
          }

          // Add violation markers if available
          if (payload.violations && payload.violations.length > 0) {
            const violationData = samples.map((s, idx) => {
              const violation = payload.violations.find(v => v.index === idx);
              return violation ? s.speed : null;
            });

            series.push({
              name: 'Violations',
              type: 'scatter',
              data: violationData,
              symbolSize: 8,
              itemStyle: { color: '#ff0000' },
              z: 3,  // Draw on top of everything
            });
          }

          const legendEntries = [];
          if (hasPSR) legendEntries.push("MPS/PSR");
          legendEntries.push("Actual Speed");
          if (payload.violations && payload.violations.length > 0) {
            legendEntries.push("Violations");
          }
          if (brakeAreas.length) {
            legendEntries.push("Brake Feel Test");
          }

          chartInstance.setOption({
            title: {
              text: hasPSR ? 'Speed Profile with PSR/MPS Overlay' : 'Speed Profile',
              left: 'center',
              top: 5,
              textStyle: { fontSize: 14, fontWeight: 600, color: '#0b3d91' }
            },
            tooltip: {
              trigger: 'axis',
              formatter: function(params) {
                let tip = `<b>Distance: ${params[0].axisValue} km</b><br/>`;
                params.forEach(param => {
                  if (param.value !== null) {
                    const color = param.color;
                    tip += `<span style="display:inline-block;margin-right:5px;border-radius:50%;width:10px;height:10px;background-color:${color};"></span>`;
                    tip += `${param.seriesName}: ${param.value} km/h<br/>`;
                  }
                });
                return tip;
              }
            },
            legend: {
              data: legendEntries,
              top: 28,
              textStyle: { fontSize: 10 }
            },
            grid: { left: 50, right: 30, top: 65, bottom: 50 },
            xAxis: {
              type: 'category',
              data: distances,
              name: 'Cumulative Distance (km)',
              nameLocation: 'middle',
              nameGap: 30,
              axisLabel: { fontSize: 9, rotate: 45 }
            },
            yAxis: {
              type: 'value',
              name: 'Speed (km/h)',
              nameLocation: 'middle',
              nameGap: 35,
              axisLabel: { fontSize: 9 }
            },
            series: series
          });
          renderSegmentCharts(samples, payload.station_markers, brakeTests);
          renderPlatformEntryCharts(samples, payload.station_markers, payload.platform_entry_data);
          renderBrakeFeelChart(samples, brakeTests, payload.first_halt_index);
          renderTripSummary(payload.station_markers, brakeTests, samples);

        } catch (err) {
          console.error(err);
          alert("Unable to load chart data");
        }
      }

      const onFilesSelected = (files) => {
        if (!files || !files.length) {
          fileInfo.textContent = "No file selected yet.";
          return;
        }
        const file = files[0];
        fileInfo.textContent = `${file.name} • ${(file.size / 1024).toFixed(
          1
        )} KB`;
      };

      uploadZone.addEventListener("click", (e) => {
        // Only trigger if not clicking the input itself
        if (e.target !== fileInput) {
          fileInput.click();
        }
      });
      uploadZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () =>
        uploadZone.classList.remove("dragover")
      );
      uploadZone.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadZone.classList.remove("dragover");
        onFilesSelected(e.dataTransfer.files);
      });
      fileInput.addEventListener("change", (e) =>
        onFilesSelected(e.target.files)
      );

      processBtn.addEventListener("click", async () => {
        processBtn.disabled = true;
        processBtn.textContent = "Processing...";
        showLoading("Uploading and analyzing SPM data...");
        hidePdfButton();
        hideCsvButton();

        try {
          // Upload file first
          const uploadResult = await uploadFile();

          if (uploadResult && uploadResult.success) {
            currentRunId = uploadResult.run_id;

            // Show toast if existing record was replaced
            if (uploadResult.replaced_existing) {
              showToast("Previous analysis replaced with new data");
            }

            // Show success message
            const summary = uploadResult.summary;
            
            // 1. Show the Header
    document.getElementById("pdfHeader").style.display = "flex"; // Use flex to keep alignment

    // 2. Set "Date of Analysis" (Current Date)
    const today = new Date();
    // Formats to "26/12/2025" (Day/Month/Year)
    const dateStr = today.toLocaleDateString('en-GB', {
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric'
    });
    document.getElementById("headerAnalysisDate").textContent = dateStr;

     // --- 1. Show the Section ---
    document.getElementById("reportMetadata").style.display = "block";

    // --- 2. Get Input Values ---
    const trainNo = document.getElementById("trainNumber").value || "N/A";
    const staffText = document.getElementById("staffId").options[document.getElementById("staffId").selectedIndex].text;
    const fromStn = document.getElementById("fromStation").value || "?";
    const toStn = document.getElementById("toStation").value || "?";
    const analystSelect = document.getElementById("analysedBy");
    const analyst = analystSelect.selectedIndex > 0 ? analystSelect.options[analystSelect.selectedIndex].text : "Admin";
    const unitNo = document.getElementById("unitNumber").value || "-";
    
    // --- 3. Format Date of Working ---
    let workingDate = document.getElementById("dateOfWorking").value;
    if(workingDate) {
       // Convert YYYY-MM-DD to DD/MM/YYYY for display
       const d = new Date(workingDate);
       workingDate = d.toLocaleDateString('en-GB'); 
    } else {
       workingDate = "-";
    }

    // --- 4. Populate the Grid ---
    document.getElementById("metaDate").textContent = workingDate;
    document.getElementById("metaStaff").textContent = staffText;
    document.getElementById("metaRoute").textContent = `${fromStn} ➝ ${toStn}`;
    document.getElementById("metaUnit").textContent = getUnitRakeShedString(unitNo);
    document.getElementById("metaAnalyst").textContent = analyst;

    // CLUBBING TRAIN NUMBER & TYPE
    // Derive train service (Slow/Fast) from train number prefix
    const trainService = getTrainService(trainNo);
    document.getElementById("metaTrainInfo").textContent = `${trainNo} / ${trainService}`;

    // NOMINATED CLI - Auto-detect from selected staff's nominated_cli_id
    const selectedStaffHrms = document.getElementById("staffId").value;
    let nominatedCliName = "Not Assigned";
    if (selectedStaffHrms && staffData[selectedStaffHrms]) {
      const staff = staffData[selectedStaffHrms];
      if (staff.nominated_cli_id) {
        // Look up CLI name from select options
        const cliSelect = document.getElementById("analysedBy");
        for (let opt of cliSelect.options) {
          if (opt.dataset.cliId == staff.nominated_cli_id) {
            nominatedCliName = opt.textContent;
            break;
          }
        }
      }
    }
    document.getElementById("metaCli").textContent = nominatedCliName;

    // METRICS FROM SUMMARY - Fix: divide by 1000 if value is in meters
    let totalDistKm = summary.total_distance || 0;
    if (totalDistKm > 200) {
      // Likely in meters, convert to km
      totalDistKm = totalDistKm / 1000;
    }
    document.getElementById("metaDistance").textContent = totalDistKm.toFixed(2) + " km";
    document.getElementById("metaMaxSpeed").textContent = (summary.max_speed || 0) + " km/h";
    
    // TIMESTAMPS
    if (uploadResult.start_time) document.getElementById("metaDepTime").textContent = uploadResult.start_time;
    if (uploadResult.end_time) document.getElementById("metaArrTime").textContent = uploadResult.end_time;
    if (uploadResult.duration) document.getElementById("metaRunTime").textContent = uploadResult.duration;
            let message = `✓ Upload successful!\n\n` +
              `Rows: ${uploadResult.rows_processed}\n` +
              `Max Speed: ${summary.max_speed} km/h\n` +
              `Avg Speed: ${summary.avg_speed.toFixed(1)} km/h\n` +
              `Total Distance: ${summary.total_distance.toFixed(2)} km\n`;

            // Add PSR/MPS info if available
            if (summary.psr_calculated) {
              message += `\n✓ PSR/MPS: Calculated\n`;
              message += `Train Type: ${uploadResult.train_type || 'unknown'}\n`;
              message += `Halts Detected: ${uploadResult.halts_detected || 0}\n`;

              if (uploadResult.violation_count > 0) {
                message += `\n⚠️ Violations Found: ${uploadResult.violation_count}\n`;
                const vsum = uploadResult.violations_summary;
                if (vsum.critical > 0) message += `  • Critical: ${vsum.critical}\n`;
                if (vsum.severe > 0) message += `  • Severe: ${vsum.severe}\n`;
                if (vsum.moderate > 0) message += `  • Moderate: ${vsum.moderate}\n`;
                if (vsum.minor > 0) message += `  • Minor: ${vsum.minor}\n`;
              }
            }

            alert(message);

            // Render overspeed events table
            renderOverspeedEvents(uploadResult.overspeed_events || [], uploadResult.overspeed_summary || {});

            // Display abnormality summary text
            const abnormalityEl = document.getElementById("abnormalityText");
            if (abnormalityEl && uploadResult.abnormality_text) {
              abnormalityEl.textContent = uploadResult.abnormality_text;
              // Color code based on content
              if (uploadResult.abnormality_text === "NO ABNORMALITY") {
                abnormalityEl.style.color = "#28a745";  // Green
              } else {
                abnormalityEl.style.color = "#dc3545";  // Red
              }
            }

            // Load chart data for this run
            showLoading("Loading charts...");
            await loadChartData(currentRunId);

            // Show PDF and CSV export buttons after successful processing
            showPdfButton();
            showCsvButton();
          }
        } catch (err) {
          console.error(err);
          alert("Processing failed: " + err.message);
        } finally {
          hideLoading();
          processBtn.disabled = false;
          processBtn.textContent = "Process Run";
        }
      });

      // PDF Export button click handler
      document.getElementById("pdfBtn").addEventListener("click", exportPDF);

      clearBtn.addEventListener("click", () => {
        fileInput.value = "";
        fileInfo.textContent = "No file selected yet.";
        // Reset Tom Select dropdown
        if (staffSelect) {
          staffSelect.clear();
        }
        document.getElementById("fromStation").selectedIndex = 0;
        document.getElementById("toStation").selectedIndex = 0;
        document.getElementById("trainNumber").value = "";
        document.getElementById("notes").value = "";
        document.getElementById("unitNumber").value = "";
        document.getElementById("dateOfWorking").value = "";
        document.getElementById("analysedBy").selectedIndex = 0;
        // Hide report sections
        document.getElementById("pdfHeader").style.display = "none";
        document.getElementById("reportMetadata").style.display = "none";
        hidePdfButton();
        hideCsvButton();
        // Clear charts
        disposeSegmentCharts();
        disposePlatformEntryCharts();
        disposeBrakeFeelChart();
        if (chart) {
          chart.clear();
        }
        // Clear railway line SVG
        const svg = document.getElementById('railwayLine');
        if (svg) svg.innerHTML = '';
      });

      // Make chart responsive
      window.addEventListener("resize", () => {
        if (chart) {
          chart.resize();
        }
        if (brakeFeelChart) {
          brakeFeelChart.resize();
        }
        segmentCharts.forEach((segChart) => segChart.resize());
        platformEntryCharts.forEach((peChart) => peChart.resize());
      });

document.getElementById("btnBack")?.addEventListener("click", () => {
  if (document.referrer) return (window.location.href = document.referrer);
  window.location.href = "/div/spm-hub.html";
});




    </script>
  </body>
</html>
