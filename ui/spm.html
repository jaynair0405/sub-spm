<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SPM Insights Console</title>
    <link
      rel="preconnect"
      href="https://fonts.googleapis.com"
    />
    <link
      rel="preconnect"
      href="https://fonts.gstatic.com"
      crossorigin
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --brand: #0b3d91;
        --brand-soft: #eef3ff;
        --accent: #f0b429;
        --border: #d7ddec;
        --text: #1f2533;
        --muted: #5b6070;
        --card: #ffffff;
        --bg: #f5f7fb;
      }
      .summary-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 12px;
        font-size: 0.9rem;
      }
      .summary-table th {
        text-align: left;
        padding: 10px;
        background: #eef3ff;
        border-bottom: 1px solid var(--border);
        color: var(--brand);
        font-weight: 600;
      }
      .summary-table td {
        padding: 8px 10px;
        border-bottom: 1px solid var(--border);
      }
      .summary-table .section-title {
        background: #f5f7fb;
        font-weight: 600;
      }
      .no-data {
        text-align: center;
        color: var(--muted);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
        background: linear-gradient(135deg, var(--bg), #edf1fc);
        color: var(--text);
        min-height: 100vh;
      }
      .page-shell {
        max-width: 1100px;
        margin: 0 auto;
        padding: 20px 22px 40px;
      }
      header {
        background: var(--brand);
        color: #fff;
        padding: 20px 24px;
        border-radius: 18px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 20px;
        box-shadow: 0 20px 45px rgba(11, 61, 145, 0.25);
      }
      header h1 {
        margin: 0;
        font-size: 1.8rem;
        letter-spacing: 0.01em;
      }
      header span {
        font-size: 0.95rem;
        opacity: 0.95;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.1);
        font-size: 0.85rem;
      }
      .content {
        margin-top: 24px;
      }
      .card {
        background: var(--card);
        border-radius: 16px;
        padding: 18px 20px;
        margin-bottom: 16px;
        border: 1px solid var(--border);
        box-shadow: 0 15px 60px rgba(15, 27, 65, 0.08);
      }
      .card h2 {
        margin: 0 0 18px;
        font-size: 1.2rem;
        color: var(--brand);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(230px, 1fr));
        gap: 18px;
        margin-bottom: 10px;
      }
      label {
        display: flex;
        flex-direction: column;
        gap: 6px;
        font-size: 0.92rem;
        color: var(--muted);
      }
      input,
      select {
        font: inherit;
        padding: 11px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: #fff;
        transition: border 0.15s ease, box-shadow 0.15s ease;
      }
      input:focus,
      select:focus {
        border-color: var(--brand);
        box-shadow: 0 0 0 3px rgba(11, 61, 145, 0.15);
        outline: none;
      }
      .upload-zone {
        position: relative;
        border: 2px dashed #b8c6e3;
        border-radius: 16px;
        padding: 24px;
        text-align: center;
        background: var(--brand-soft);
        transition: border-color 0.2s ease, background 0.2s ease;
        cursor: pointer;
      }
      .upload-zone.dragover {
        border-color: var(--brand);
        background: #dfebff;
      }
      .upload-zone h3 {
        margin: 6px 0 8px;
        font-size: 1.2rem;
        color: var(--brand);
      }
      .upload-zone p {
        margin: 0;
        font-size: 0.9rem;
        color: var(--muted);
      }
      .upload-zone button {
        margin-top: 16px;
      }
      .upload-zone input {
        position: absolute;
        inset: 0;
        opacity: 0;
        pointer-events: none;
      }
      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin-top: 16px;
      }
      button {
        font: inherit;
        border: none;
        border-radius: 14px;
        padding: 12px 20px;
        cursor: pointer;
        background: var(--brand);
        color: #fff;
        transition: transform 0.15s ease, box-shadow 0.2s ease;
        box-shadow: 0 12px 24px rgba(11, 61, 145, 0.2);
      }
      button.secondary {
        background: var(--accent);
        color: #1d1400;
        box-shadow: 0 12px 24px rgba(240, 180, 41, 0.35);
      }
      button:hover {
        transform: translateY(-1px);
      }
      .panels {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: 22px;
      }
      .panel-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
        font-weight: 600;
        color: var(--brand);
      }
      .table-wrapper {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: 16px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 420px;
      }
      th,
      td {
        padding: 12px 14px;
        border-bottom: 1px solid var(--border);
        font-size: 0.9rem;
        text-align: left;
      }
      th {
        background: #f8faff;
        font-weight: 600;
        color: var(--muted);
      }
      tbody tr:last-child td {
        border-bottom: none;
      }
      #chart {
        width: 100%;
        height: 320px;
        cursor: crosshair;
      }
      .brakefeel-chart {
        width: 100%;
        height: 260px;
        border: 1px solid var(--border);
        border-radius: 12px;
      }
      .segment-charts {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .segment-chart {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px 14px;
        background: #fdfdff;
      }
      .segment-title {
        font-size: 0.92rem;
        font-weight: 600;
        margin-bottom: 8px;
        color: var(--brand);
      }
      .segment-chart-inner {
        width: 100%;
        height: 220px;
      }
      .subtle {
        color: var(--muted);
        font-size: 0.85rem;
      }
      @media (max-width: 680px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
        .upload-zone {
          padding: 24px;
        }
      }
      .meta-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 24px 20px; /* Row gap 24px, Column gap 20px */
  margin-top: 10px;
}

.meta-item {
  display: flex;
  flex-direction: column;
  gap: 5px;
  position: relative;
}

/* Optional: Add a subtle divider line between rows on mobile if needed, 
   but clean spacing usually looks better */

.meta-label {
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--muted);
  font-weight: 600;
}

.meta-value {
  font-size: 1.1rem;
  font-weight: 600;
  color: var(--brand);
  font-family: "Inter", monospace; /* Monospace numbers look technical and precise */
}

/* Specific styling for the header of this section to match PDF "Office of Sr DEE" feel */
.report-header-badge {
  background: var(--brand-soft);
  color: var(--brand);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 0.8rem;
  font-weight: 600;
}
/* Report Header Styles */
.report-print-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 5px;
  border-bottom: 3px double var(--brand); /* Double line for official look */
  margin-bottom: 20px;
  background: #fff;
}

.header-left {
  text-align: left;
}

.railway-title {
  font-weight: 800;
  font-size: 1.1rem;
  color: var(--brand);
  text-transform: uppercase;
  letter-spacing: 0.05em;
  line-height: 1.2;
}

.division-title {
  font-weight: 600;
  font-size: 0.9rem;
  color: var(--text);
  text-transform: uppercase;
  margin-bottom: 4px;
}

.office-title {
  font-size: 0.85rem;
  color: var(--muted);
  font-weight: 500;
}

.header-center {
  flex-grow: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.logo-placeholder {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  background: #f0f4ff; /* Light blue background for placeholder */
  border: 2px dashed var(--brand);
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--brand);
  font-size: 0.8rem;
  text-align: center;
  font-weight: 600;
}

/* If you have a real logo, use this class on the IMG tag inside header-center */
.real-logo {
  height: 80px;
  width: auto;
}

.header-right {
  text-align: right;
}

.report-name {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--brand);
  margin-bottom: 6px;
  letter-spacing: -0.02em;
}

.analysis-meta {
  font-size: 0.9rem;
  color: var(--text);
}

.analysis-date {
  font-weight: 600;
  color: var(--text);
}

/* Print specific adjustments */
@media print {
  body { background: white; }
  .page-shell { padding: 0; max-width: 100%; }
  .report-print-header { margin-top: 0; }
  /* Hide the Upload/Input section when printing */
  section.card:nth-of-type(1) { display: none !important; } 
  header { display: none !important; } /* Hide the blue app header */
}
    </style>
  </head>
  <body>
    <div class="page-shell">
      <header>
        <div>
          <div class="badge">Central Railway • BB Divn-Suburban • SPM</div>
          <h1>Suburban Performance Monitor</h1>
          <span>Upload SPM runs, select staff, and review train performance visually.</span>
        </div>
        <div class="badge">BB TRSO - Digital Workplace</div>
      </header>

      <main class="content">
        <section class="card">
          <h2>Upload Run & Assign Metadata</h2>
          <div
            class="upload-zone"
            id="uploadZone"
          >
            <input
              type="file"
              id="fileInput"
              accept=".csv,.xlsx,.xls"
            />
            <h3>Drop CSV/Excel file here</h3>
            <p>Supported formats: CSV, XLSX, XLS</p>
            <button type="button">Browse Files</button>
          </div>
          <p
            class="subtle"
            id="fileInfo"
          >
            No file selected yet.
          </p>

          <div class="grid">
            <label>
              Staff ID
              <select id="staffId">
                <option value="" selected>Select staff (from DB soon)</option>
                <option value="STF1234">STF1234 • Vinod Singh</option>
                <option value="STF1956">STF1956 • Ravi Sharma</option>
                <option value="STF2277">STF2277 • Anita Desai</option>
              </select>
            </label>
            <label>
              From Station
              <input
                type="text"
                id="fromStation"
                placeholder="e.g., CSMT, VDLR, TNA (optional)"
              />
            </label>
            <label>
              To Station
              <input
                type="text"
                id="toStation"
                placeholder="e.g., KYN, PNVL, TNA (optional)"
              />
            </label>
            <label>
              Train Number
              <input
                type="text"
                id="trainNumber"
                placeholder="e.g., K40, 96035"
              />
            </label>
            <label>
              Date of Working
              <input
                type="date"
                id="dateOfWorking"
              />
            </label>
            <label>
              Analysed By
              <input
                type="text"
                id="analysedBy"
                placeholder="Name of analyst"
              />
            </label>
            <label>
              Unit Number
              <input
                type="text"
                id="unitNumber"
                placeholder="e.g., 2231"
              />
            </label>
            <label>
              Notes
              <input
                type="text"
                id="notes"
                placeholder="Optional remarks"
              />
            </label>
          </div>
          <div class="actions">
            <button type="button" id="processBtn">Process Run</button>
            <button
              type="button"
              class="secondary"
              id="clearBtn"
            >
              Reset Form
            </button>
          </div>
        </section>
<div id="pdfHeader" class="report-print-header" style="display: none;">
  
  <div class="header-left">
    <div class="railway-title">CENTRAL RAILWAY</div>
    <div class="division-title">MUMBAI DIVISION</div>
    <div class="office-title">OFFICE OF SR. DEE (TRO)</div>
  </div>

  <div class="header-center">
    <div class="logo-placeholder">
      Indian<br>Railways
    </div>
  </div>

  <div class="header-right">
    <div class="report-name">SPM ANALYSIS REPORT</div>
    <div class="analysis-meta">
      Date of Analysis: <span id="headerAnalysisDate" class="analysis-date">-</span>
    </div>
  </div>

</div>
       <section class="card" id="reportMetadata" style="display: none;">
  <div class="panel-header">
    <div style="display:flex; align-items:center; gap:12px;">
      <span>Analysis Report Summary</span>
      <!-- <span class="report-header-badge">CENTRAL RAILWAY • MUMBAI</span> -->
    </div>
    </div>

  <div class="meta-grid">
    <div class="meta-item">
      <span class="meta-label">Date of Working</span>
      <span class="meta-value" id="metaDate">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Train Service</span>
      <span class="meta-value" id="metaTrainInfo">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">LP / Staff Name</span>
      <span class="meta-value" id="metaStaff">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Nominated CLI</span>
      <span class="meta-value" id="metaCli">-</span>
    </div>

    <div class="meta-item">
      <span class="meta-label">Departure</span>
      <span class="meta-value" id="metaDepTime">--:--:--</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Arrival</span>
      <span class="meta-value" id="metaArrTime">--:--:--</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Total Distance</span>
      <span class="meta-value" id="metaDistance">- km</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Running Time</span>
      <span class="meta-value" id="metaRunTime">- min</span>
    </div>

    <div class="meta-item">
      <span class="meta-label">Route</span>
      <span class="meta-value" id="metaRoute">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Unit / Rake</span>
      <span class="meta-value" id="metaUnit">-</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Max Speed</span>
      <span class="meta-value" id="metaMaxSpeed">- km/h</span>
    </div>
    <div class="meta-item">
      <span class="meta-label">Analysed By</span>
      <span class="meta-value" id="metaAnalyst">-</span>
    </div>
  </div>
</section>

        <section class="card">
          <div class="panel-header">
            <span>Platform Entry Overview</span>
            <span class="subtle">Platform entry speeds • Green: ≤43 km/h • Red: >43 km/h</span>
          </div>
          <div style="width: 100%; height: 150px;">
            <svg id="railwayLine" style="width: 100%; height: 100%;"></svg>
          </div>
        </section>

        <section class="card">
          <div class="panel-header">
            <span>Speed Profile Chart</span>
            <span class="subtle">Distance vs Speed</span>
          </div>
          <div id="chart"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Segmented Speed Profiles</span>
            <span class="subtle">Same chart split into 4-5 station windows</span>
          </div>
          <div id="segmentCharts" class="segment-charts"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Platform Entry Analysis</span>
            <span class="subtle">Speed drop from PF entry to stop</span>
          </div>
          <div id="platformEntryCharts" class="segment-charts"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Brake Feel Test</span>
            <span class="subtle">Acceleration → braking → recovery window</span>
          </div>
          <div id="brakeFeelStatus" class="subtle" style="margin-bottom:8px;">Brake feel detection pending...</div>
          <div id="brakeFeelChart" class="brakefeel-chart"></div>
        </section>
        <section class="card">
          <div class="panel-header">
            <span>Trip Summary</span>
            <span class="subtle">Exceptions & observations</span>
          </div>
          <table class="summary-table" id="tripSummaryTable">
            <thead>
              <tr><th>Category</th><th>Details</th></tr>
            </thead>
            <tbody>
              <tr class="section-title"><td colspan="2">Platform Entry Speeds</td></tr>
              <tr>
                <td colspan="2">
                  <table class="summary-table">
                    <thead>
                      <tr>
                        <th>PF Entry > 40</th>
                        <th>Mid PF > 25</th>
                        <th>1 Coach > 10</th>
                      </tr>
                    </thead>
                    <tbody id="pfSummaryBody">
                      <tr><td colspan="3" class="no-data">No exceptions detected</td></tr>
                    </tbody>
                  </table>
                </td>
              </tr>
              <tr class="section-title"><td colspan="2">MPS/PSR Violations</td></tr>
              <tr><td colspan="2">No data available</td></tr>
              <tr class="section-title"><td colspan="2">Brake Feel Test</td></tr>
              <tr><td>Train start time</td><td id="bftStartTime">-</td></tr>
              <tr><td>Test time</td><td id="bftTestTime">-</td></tr>
              <tr><td>Test speed</td><td id="bftTestSpeed">-</td></tr>
              <tr><td>Speed dropped to</td><td id="bftDropSpeed">-</td></tr>
              <tr><td>Observation</td><td id="bftObservation">No data</td></tr>
            </tbody>
          </table>
        </section>
      </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/echarts@5"></script>
    <script>
      const uploadZone = document.getElementById("uploadZone");
      const fileInput = document.getElementById("fileInput");
      const fileInfo = document.getElementById("fileInfo");
      const processBtn = document.getElementById("processBtn");
      const clearBtn = document.getElementById("clearBtn");

      const renderExceptionsTable = (markers = []) => {
        const tbody = document.getElementById("pfSummaryBody");
        if (!tbody) return;

        const pfEntries = [];
        const midEntries = [];
        const oneEntries = [];

        (markers || []).forEach((marker) => {
          if (marker.platform_entry_speed > 40) {
            pfEntries.push(`${marker.station} · ${marker.platform_entry_speed} km/h`);
          }
          if (marker.mid_platform_speed > 25) {
            midEntries.push(`${marker.station} · ${marker.mid_platform_speed} km/h`);
          }
          if (marker.one_coach_speed > 10) {
            oneEntries.push(`${marker.station} · ${marker.one_coach_speed} km/h`);
          }
        });

        const maxRows = Math.max(pfEntries.length, midEntries.length, oneEntries.length);
        if (maxRows === 0) {
          tbody.innerHTML = `<tr><td colspan="3" class="no-data">No exceptions detected</td></tr>`;
          return;
        }

        let rowsHtml = "";
        for (let i = 0; i < maxRows; i++) {
          rowsHtml += `
            <tr>
              <td>${pfEntries[i] ?? "-"}</td>
              <td>${midEntries[i] ?? "-"}</td>
              <td>${oneEntries[i] ?? "-"}</td>
            </tr>
          `;
        }
        tbody.innerHTML = rowsHtml;
      };

      let chart = null;
      let segmentCharts = [];
      let platformEntryCharts = [];
      let brakeFeelChart = null;
      const brakeFeelStatusEl = document.getElementById("brakeFeelStatus");
      const tripSummaryTable = document.getElementById("tripSummaryTable");

      function initChart() {
        const chartEl = document.getElementById("chart");
        if (chartEl && !chart) {
          chart = echarts.init(chartEl);
        }
        return chart;
      }

      function disposeSegmentCharts() {
        segmentCharts.forEach((c) => c.dispose());
        segmentCharts = [];
        const container = document.getElementById("segmentCharts");
        if (container) {
          container.innerHTML = "";
        }
      }

      function disposePlatformEntryCharts() {
        platformEntryCharts.forEach((c) => c.dispose());
        platformEntryCharts = [];
        const container = document.getElementById("platformEntryCharts");
        if (container) {
          container.innerHTML = "";
        }
      }

      function disposeBrakeFeelChart() {
        if (brakeFeelChart) {
          brakeFeelChart.dispose();
          brakeFeelChart = null;
        }
        const container = document.getElementById("brakeFeelChart");
        if (container) {
          container.innerHTML = "";
        }
        if (brakeFeelStatusEl) {
          brakeFeelStatusEl.textContent = "Brake feel detection pending...";
        }
      }

      function buildStationGroups(markers, chunkSize = 5) {
        if (!markers || markers.length === 0) return [];

        const sorted = [...markers].sort(
          (a, b) => a.sample_index - b.sample_index
        );

        const groups = [];
        let i = 0;
        while (i < sorted.length) {
          const end = Math.min(i + chunkSize, sorted.length);
          let group = sorted.slice(i, end);

          if (group.length === 1 && groups.length > 0) {
            groups[groups.length - 1] =
              groups[groups.length - 1].concat(group);
          } else {
            groups.push(group);
          }

          if (group.length >= 2) {
            i += chunkSize - 1;
          } else {
            i = end;
          }
        }

        if (groups.length > 1 && groups[groups.length - 1].length === 1) {
          groups[groups.length - 2] = groups[groups.length - 2].concat(
            groups.pop()
          );
        }

        return groups.filter((group) => group.length >= 2);
      }

      function renderSegmentCharts(samples, markers, brakeTests = []) {
        disposeSegmentCharts();

        let workingMarkers = markers;
        if (!workingMarkers || workingMarkers.length < 2) {
          if (!samples || samples.length < 2) {
            return;
          }
          const syntheticCount = 4;
          const step = Math.floor(samples.length / syntheticCount);
          workingMarkers = [];
          for (let i = 0; i <= syntheticCount; i++) {
            const sampleIndex = Math.min(i * step, samples.length - 1);
            workingMarkers.push({
              station: i === 0 ? "Start" : i === syntheticCount ? "End" : `Segment ${i}`,
              sample_index: sampleIndex,
              platform_entry_speed: null,
              mid_platform_speed: null,
              one_coach_speed: null,
            });
          }
        }

        const stationGroups = buildStationGroups(workingMarkers);
        if (!stationGroups.length) {
          return;
        }

        const container = document.getElementById("segmentCharts");
        stationGroups.forEach((group, idx) => {
          const startIdx = Math.max(group[0].sample_index, 0);
          const endIdx = Math.min(
            group[group.length - 1].sample_index,
            samples.length - 1
          );
          const segmentSamples = samples.slice(startIdx, endIdx + 1);

          if (segmentSamples.length < 2) {
            return;
          }

          const chartWrapper = document.createElement("div");
          chartWrapper.className = "segment-chart";
          chartWrapper.id = `segment-chart-${idx}`;

          const title = document.createElement("div");
          title.className = "segment-title";
          const firstStation = group[0].station;
          const lastStation = group[group.length - 1].station;
          title.textContent = `${idx + 1}. ${firstStation} → ${lastStation}`;

          chartWrapper.appendChild(title);
          const chartDiv = document.createElement("div");
          chartDiv.className = "segment-chart-inner";
          chartWrapper.appendChild(chartDiv);
          container.appendChild(chartWrapper);

          const segmentChart = echarts.init(chartDiv);
          segmentCharts.push(segmentChart);

          const segmentDistances = segmentSamples.map((s) =>
            s.cumulative_distance ? s.cumulative_distance.toFixed(1) : "0.0"
          );
          const segmentSpeeds = segmentSamples.map((s) => s.speed);
          const segmentPSR = segmentSamples.map((s) => s.psr || null);
          const hasPSR = segmentPSR.some((v) => v !== null);

          const markLines = group.map((marker) => ({
            xAxis: marker.sample_index - startIdx,
            label: {
              formatter: marker.station,
              position: "insideEndTop",
              fontSize: 9,
              color: "#333",
            },
            lineStyle: {
              color: "#999",
              type: "dashed",
            },
          }));

          const series = [];
          if (hasPSR) {
            series.push({
              name: "MPS/PSR",
              type: "line",
              data: segmentPSR,
              smooth: false,
              lineStyle: { color: "#00c800", width: 1 },
              areaStyle: { color: "rgba(0, 200, 0, 0.25)" },
              showSymbol: false,
              z: 1,
            });
          }

          series.push({
            name: "Speed",
            type: "line",
            data: segmentSpeeds,
            smooth: false,
            lineStyle: { color: "#007bff", width: 2 },
            areaStyle: { color: "rgba(0, 123, 255, 0.1)" },
            symbol: "circle",
            symbolSize: 4,
            z: 2,
            markLine: markLines.length
              ? {
                  data: markLines,
                }
              : undefined,
          });

          const segmentBrakeAreas = (brakeTests || [])
            .filter(
              (test) =>
                test.end_index >= startIdx &&
                test.start_index <= endIdx
            )
            .map((test) => {
              const clampedStart = Math.max(test.start_index - startIdx, 0);
              const clampedEnd = Math.min(
                test.end_index - startIdx,
                segmentSamples.length - 1
              );
              return [
                {
                  xAxis: clampedStart,
                  itemStyle: { color: "rgba(255,0,0,0.08)" },
                },
                { xAxis: clampedEnd },
              ];
            });

          if (segmentBrakeAreas.length) {
            series.push({
              name: "Brake Feel Test",
              type: "line",
              data: [],
              markArea: {
                silent: true,
                data: segmentBrakeAreas,
              },
            });
          }

          segmentChart.setOption({
            tooltip: { trigger: "axis" },
            legend: {
              data: hasPSR
                ? ["Speed", "MPS/PSR", "Brake Feel Test"]
                : ["Speed", "Brake Feel Test"],
            },
            grid: {
              left: "3%",
              right: "4%",
              bottom: "8%",
              containLabel: true,
            },
            xAxis: {
              type: "category",
              data: segmentDistances,
              axisLabel: { fontSize: 9 },
            },
            yAxis: {
              type: "value",
              name: "Speed (km/h)",
              nameLocation: "middle",
              nameGap: 35,
              axisLabel: { fontSize: 9 },
            },
            series,
          });
        });
      }

      function renderPlatformEntryCharts(samples, markers, platformEntryData) {
        disposePlatformEntryCharts();

        if (!markers || !platformEntryData) {
          return;
        }

        // Filter markers to only include stations with platform entry data
        const validMarkers = markers.filter(m =>
          m.platform_entry_speed !== null &&
          m.platform_entry_speed !== 0 &&
          platformEntryData[m.station]
        );

        if (validMarkers.length === 0) {
          return;
        }

        const container = document.getElementById("platformEntryCharts");

        // Check if samples are in meters or km
        const maxDistance = Math.max(...samples.map(s => s.cumulative_distance));
        const sampleInMeters = maxDistance > 100;

        const stationsToRender = validMarkers;  // All halts
        const colors = ['#4285f4', '#ea4335', '#fbbc05', '#34a853', '#9c27b0', '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7'];
        const stationSeries = [];

        stationsToRender.forEach((marker, idx) => {
          const stationName = marker.station;
          const entryData = platformEntryData[stationName];

          if (!entryData) return;

          const haltDistanceKm = entryData.halt_distance;
          const entryDistanceKm = entryData.entry_distance;

          // Convert to same units as samples
          const haltDistance = sampleInMeters ? haltDistanceKm * 1000 : haltDistanceKm;
          const entryDistance = sampleInMeters ? entryDistanceKm * 1000 : entryDistanceKm;

          // Find all samples between entry and halt
          const stationSamples = samples.filter(s => {
            const dist = s.cumulative_distance;
            return dist >= entryDistance && dist <= haltDistance;
          });

          if (stationSamples.length < 2) return;

          // Prepare data for this station
          const dataPoints = [];

          for (let s of stationSamples) {
            const distFromHalt = haltDistance - s.cumulative_distance;
            if (distFromHalt < 0) break;

            const distFromHaltMeters = sampleInMeters ? distFromHalt : distFromHalt * 1000;
            dataPoints.push([Math.round(distFromHaltMeters), s.speed]);

            if (s.speed === 0) break;
          }

          if (dataPoints.length > 0) {
            stationSeries.push({
              name: stationName,
              data: dataPoints,
              color: colors[idx % colors.length]
            });
          }
        });

        if (stationSeries.length === 0) return;

        const linesPerChart = 5;
        let groupCounter = 0;

        for (let start = 0; start < stationSeries.length; start += linesPerChart) {
          const groupSeries = stationSeries.slice(start, start + linesPerChart).map(series => ({
            name: series.name,
            type: 'line',
            data: series.data.map(point => [...point]),
            smooth: 0.4,
            lineStyle: { color: series.color, width: 3 },
            symbol: 'circle',
            symbolSize: 0,
            showSymbol: false
          }));

          if (!groupSeries.length) continue;

          groupSeries[0].markLine = {
            silent: true,
            symbol: 'none',
            label: {
              position: 'end',
              formatter: '{b}',
              fontSize: 9
            },
            lineStyle: {
              type: 'dashed',
              color: '#999',
              width: 1
            },
            data: [
              { xAxis: 126, name: '126m' },
              { xAxis: 17, name: '17m' }
            ]
          };

          const chartWrapper = document.createElement("div");
          chartWrapper.className = "segment-chart";

          const title = document.createElement("div");
          title.className = "segment-title";
          groupCounter += 1;
          title.textContent = `Speed vs Distance - Group ${groupCounter}`;

          chartWrapper.appendChild(title);
          const chartDiv = document.createElement("div");
          chartDiv.className = "segment-chart-inner";
          chartWrapper.appendChild(chartDiv);
          container.appendChild(chartWrapper);

          const platformChart = echarts.init(chartDiv);
          platformEntryCharts.push(platformChart);

          platformChart.setOption({
            tooltip: {
              trigger: 'axis',
              formatter: function(params) {
                if (!params || params.length === 0) return '';
                const dist = params[0].value[0];
                let result = `Distance: ${dist}m from halt<br/>`;
                params.forEach(p => {
                  if (p.value && p.value[1] !== null) {
                    result += `${p.seriesName}: ${p.value[1].toFixed(1)} km/h<br/>`;
                  }
                });
                return result;
              }
            },
            legend: {
              data: groupSeries.map(s => s.name),
              top: 5,
              textStyle: { fontSize: 9 }
            },
            grid: {
              left: '8%',
              right: '3%',
              bottom: '15%',
              top: '15%',
              containLabel: true
            },
            xAxis: {
              type: 'value',
              name: 'Distance',
              nameLocation: 'middle',
              nameGap: 25,
              inverse: true,
              splitNumber: 10,
              minInterval: 1,
              axisLabel: {
                fontSize: 9,
                formatter: function(value) {
                  if (value === 0) return 'Halt';
                  if (value === 17) return '17m';
                  if (value === 126) return '126m';
                  return value + 'm';
                }
              }
            },
            yAxis: {
              type: 'value',
              name: 'Speed',
              nameLocation: 'middle',
              nameGap: 35,
              min: 0,
              max: 50,
              axisLabel: { fontSize: 9 }
            },
            series: groupSeries
          });
        }
      }

      function renderBrakeFeelChart(samples, brakeTests, firstHaltIndex) {
        const container = document.getElementById("brakeFeelChart");
        if (!container) {
          return;
        }

        if (!samples || samples.length === 0) {
          disposeBrakeFeelChart();
          if (brakeFeelStatusEl) {
            brakeFeelStatusEl.textContent = "No run data available";
          }
          return;
        }

        if (!brakeFeelChart) {
          brakeFeelChart = echarts.init(container);
        }

        const distances = samples.map((s, idx) => {
          const value =
            s.cumulative_distance !== undefined && s.cumulative_distance !== null
              ? s.cumulative_distance
              : s.distance !== undefined && s.distance !== null
              ? s.distance
              : idx;
          return Number(value);
        });
        const distanceLabels = distances.map((d) =>
          Number.isFinite(d) ? d.toFixed(2) : "0.00"
        );
        const speeds = samples.map((s) => s.speed ?? 0);

        const markAreas = (brakeTests || [])
          .map((test) => {
            if (test.start_index === undefined || test.end_index === undefined) {
              return null;
            }
            const startIdx = Math.max(
              0,
              Math.min(test.start_index, distanceLabels.length - 1)
            );
            const endIdx = Math.max(
              startIdx + 1,
              Math.min(test.end_index, distanceLabels.length - 1)
            );
            return [
              {
                xAxis: distanceLabels[startIdx],
                itemStyle: { color: "rgba(255, 0, 0, 0.1)" },
                label: {
                  show: true,
                  formatter: "BFT",
                  color: "#c00",
                },
              },
              { xAxis: distanceLabels[endIdx] },
            ];
          })
          .filter(Boolean);

        if (brakeFeelStatusEl) {
          brakeFeelStatusEl.textContent =
            brakeTests && brakeTests.length
              ? "Brake feel test detected"
              : "No brake feel test detected";
        }

        brakeFeelChart.setOption({
          tooltip: { trigger: "axis" },
          legend: {
            data: markAreas.length ? ["Speed", "Brake Feel Test"] : ["Speed"],
          },
          grid: { left: 45, right: 20, top: 35, bottom: 40 },
          xAxis: {
            type: "category",
            data: distanceLabels,
            name: "Cumulative Distance (km)",
            nameLocation: "middle",
            nameGap: 30,
            axisLabel: { fontSize: 9 },
          },
          yAxis: {
            type: "value",
            name: "Speed (km/h)",
            nameLocation: "middle",
            nameGap: 35,
            axisLabel: { fontSize: 9 },
          },
          series: [
            {
              name: "Speed",
              type: "line",
              data: speeds,
              smooth: true,
              lineStyle: { color: "#0b3d91", width: 2 },
              showSymbol: false,
              markArea: markAreas.length
                ? {
                    silent: true,
                    data: markAreas,
                  }
                : undefined,
            },
          ],
        });
      }

      function renderTripSummary(stationMarkers, brakeTests, samples) {
        renderExceptionsTable(stationMarkers || []);

        const startCell = document.getElementById("bftStartTime");
        const testTimeCell = document.getElementById("bftTestTime");
        const testSpeedCell = document.getElementById("bftTestSpeed");
        const dropSpeedCell = document.getElementById("bftDropSpeed");
        const observationCell = document.getElementById("bftObservation");

        if (!startCell || !testTimeCell || !testSpeedCell || !dropSpeedCell || !observationCell) {
          return;
        }

        if (brakeTests && brakeTests.length) {
          const test = brakeTests[0];
          const startSample = samples[test.max_speed_index] || samples[test.braking_start_index] || {};
          const recoverySample = samples[test.recovery_index] || {};

          startCell.textContent = samples[0]?.timestamp ?? "-";
          testTimeCell.textContent = startSample.timestamp ?? "-";
          testSpeedCell.textContent = test.braking_start_speed != null ? `${test.braking_start_speed} km/h` : "-";
          dropSpeedCell.textContent = test.lowest_speed != null ? `${test.lowest_speed} km/h` : "-";
          observationCell.textContent = "Brake feel test detected";
        } else {
          startCell.textContent = samples[0]?.timestamp ?? "-";
          testTimeCell.textContent = "-";
          testSpeedCell.textContent = "-";
          dropSpeedCell.textContent = "-";
          observationCell.textContent = "No brake feel test detected";
        }
      }
      const CHART_API_BASE = "";
      // const CHART_API_BASE = "http://127.0.0.1:8000";
      let currentRunId = null;

      async function uploadFile() {
        const file = fileInput.files[0];
        if (!file) {
          alert("Please select a file first");
          return null;
        }
        disposeSegmentCharts();
        disposePlatformEntryCharts();
        disposeBrakeFeelChart();

        const formData = new FormData();
        formData.append("file", file);
        formData.append("staff_id", document.getElementById("staffId").value);
        formData.append("from_station", document.getElementById("fromStation").value);
        formData.append("to_station", document.getElementById("toStation").value);
        formData.append("train_number", document.getElementById("trainNumber").value);
        formData.append("date_of_working", document.getElementById("dateOfWorking").value);
        formData.append("analysed_by", document.getElementById("analysedBy").value);
        formData.append("unit_number", document.getElementById("unitNumber").value);
        formData.append("notes", document.getElementById("notes").value);

        try {
          const response = await fetch(`${CHART_API_BASE}/upload`, {
            method: "POST",
            body: formData,
          });

          if (!response.ok) {
            const errorText = await response.text();
            alert(`Upload error: ${errorText}`);
            return null;
          }

          const result = await response.json();
          return result;
        } catch (err) {
          console.error(err);
          alert("Upload failed: " + err.message);
          return null;
        }
      }

      function createRailwayLine(stationData) {
        if (!stationData || stationData.length === 0) {
          // Clear the SVG if no data
          const svg = document.getElementById('railwayLine');
          svg.innerHTML = '';
          return;
        }

        // Fixed width to fit in one view - no scrolling!
        const width = 1050;
        const height = 150;
        const padding = 30;
        const lineY = height / 2;
        const SPEED_THRESHOLD = 43; // Green ≤ 43, Red > 43

        // Get max distance for scaling
        const maxDistance = Math.max(...stationData.map(s => s.distance));

        // Set up SVG
        const svg = document.getElementById('railwayLine');
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        svg.setAttribute('width', '100%');
        svg.setAttribute('height', '100%');
        svg.style.maxWidth = '100%';

        // Clear existing content
        while (svg.firstChild) {
          svg.removeChild(svg.firstChild);
        }

        // Create main railway line
        const mainLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        mainLine.setAttribute('x1', padding);
        mainLine.setAttribute('y1', lineY);
        mainLine.setAttribute('x2', width - padding);
        mainLine.setAttribute('y2', lineY);
        mainLine.setAttribute('stroke', '#333');
        mainLine.setAttribute('stroke-width', '2.5');
        svg.appendChild(mainLine);

        // Function to calculate x position based on distance
        function getXPosition(distance) {
          return (distance / maxDistance) * (width - 2 * padding) + padding;
        }

        // Add stations
        stationData.forEach((station, index) => {
          const xPos = getXPosition(station.distance);

          // Create station circle
          const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          circle.setAttribute('cx', xPos);
          circle.setAttribute('cy', lineY);
          circle.setAttribute('r', 6);

          // Color based on speed
          if (station.speed <= SPEED_THRESHOLD) {
            circle.setAttribute('fill', '#00cc00'); // Green
            circle.setAttribute('stroke', '#009900');
          } else {
            circle.setAttribute('fill', '#ff0000'); // Red
            circle.setAttribute('stroke', '#cc0000');
          }
          circle.setAttribute('stroke-width', '1.5');
          svg.appendChild(circle);

          // Station name (alternating above/below)
          const stationText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          stationText.textContent = station.station.replace('Entry', '').trim();
          stationText.setAttribute('x', xPos);
          stationText.setAttribute('y', index % 2 === 0 ? lineY - 20 : lineY + 32);
          stationText.setAttribute('text-anchor', 'middle');
          stationText.setAttribute('font-size', '10px');
          stationText.setAttribute('font-family', 'Inter, Arial, sans-serif');
          stationText.setAttribute('font-weight', '600');
          stationText.setAttribute('fill', '#0b3d91');
          svg.appendChild(stationText);

          // Speed label (alternating above/below) - just the number
          const speedText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
          speedText.textContent = station.speed.toFixed(0);
          speedText.setAttribute('x', xPos);
          speedText.setAttribute('y', index % 2 === 0 ? lineY - 8 : lineY + 44);
          speedText.setAttribute('text-anchor', 'middle');
          speedText.setAttribute('font-size', '10px');
          speedText.setAttribute('font-family', 'Inter, Arial, sans-serif');
          speedText.setAttribute('font-weight', 'bold');
          speedText.setAttribute('fill', station.speed <= SPEED_THRESHOLD ? '#00aa00' : '#cc0000');
          svg.appendChild(speedText);
        });
      }

      async function loadChartData(runId = null) {
        try {
          const body = runId ? { run_id: runId } : {};
          const response = await fetch(`${CHART_API_BASE}/chart_data`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
          });

          if (!response.ok) {
            const errorText = await response.text();
            alert(`Chart data error: ${errorText}`);
            return;
          }

          const payload = await response.json();

          const samples = payload.samples ?? [];
          const brakeTests = payload.brake_tests ?? [];

          disposeSegmentCharts();
          disposePlatformEntryCharts();

          // Create railway line diagram from station halt data
          if (payload.station_markers && payload.station_markers.length > 0) {
            // Extract platform entry speeds for railway line
            const stationHaltData = payload.station_markers.map(marker => {
              // Use platform entry speed if available, otherwise fallback to halt speed
              const sample = samples[marker.sample_index];
              const speed = marker.platform_entry_speed !== null && marker.platform_entry_speed !== undefined
                ? marker.platform_entry_speed
                : (sample ? sample.speed : 0);

              return {
                station: marker.station,
                distance: sample ? sample.cumulative_distance : 0,
                speed: speed
              };
            }).filter(s => s.distance >= 0); // Include start station at 0 distance

            createRailwayLine(stationHaltData);
          } else {
            // Clear railway line if no station data
            createRailwayLine([]);
          }

          // Update table with station halt data showing platform entry speeds
          // Filter out starting stations (where platform_entry_speed is 0 or null)
          renderExceptionsTable(payload.station_markers || []);

          // Update chart with all data
          const distances = samples.map((s) => s.cumulative_distance ? s.cumulative_distance.toFixed(1) : s.distance.toFixed(1));
          const speeds = samples.map((s) => s.speed);
          const psrValues = samples.map((s) => s.psr || null);

          // Check if PSR data is available
          const hasPSR = psrValues.some(v => v !== null);

          const chartInstance = initChart();
          if (!chartInstance) {
            console.error("Failed to initialize chart");
            return;
          }

          // Build series array
          const series = [];

          // Add PSR/MPS series first (so it appears behind the speed line)
          if (hasPSR) {
            series.push({
              name: 'MPS/PSR',
              type: 'line',
              data: psrValues,
              smooth: false,
              lineStyle: { color: '#00c800', width: 1 },
              areaStyle: { color: 'rgba(0, 200, 0, 0.25)' },
              showSymbol: false,
              z: 1,  // Draw behind speed line
            });
          }

          // Prepare station markers (vertical dashed lines with station names)
          const stationMarkLines = [];
          if (payload.station_markers && payload.station_markers.length > 0) {
            payload.station_markers.forEach(marker => {
              stationMarkLines.push({
                xAxis: marker.sample_index,
                label: {
                  formatter: marker.station,
                  position: 'insideEndTop',
                  fontSize: 10,
                  color: '#333',
                  backgroundColor: 'rgba(255, 255, 255, 0.9)',
                  padding: [2, 4],
                  borderRadius: 3
                },
                lineStyle: {
                  color: '#888',
                  type: 'dashed',
                  width: 1
                }
              });
            });
          }

          // Add actual speed series with station markers
          series.push({
            name: 'Actual Speed',
            type: 'line',
            data: speeds,
            smooth: true,
            lineStyle: { color: '#0b3d91', width: 2 },
            showSymbol: false,
            z: 2,  // Draw on top
            markLine: stationMarkLines.length ? {
              symbol: 'none',
              data: stationMarkLines
            } : undefined
          });

          // Add brake feel areas
          const brakeAreas = brakeTests
            .map((test) => {
              const startIdx = Math.max(test.start_index, 0);
              const endIdx = Math.min(test.end_index, distances.length - 1);
              if (endIdx <= startIdx) return null;
              return [
                {
                  xAxis: distances[startIdx],
                  itemStyle: { color: "rgba(255, 0, 0, 0.1)" },
                  name: "BFT",
                },
                { xAxis: distances[endIdx] },
              ];
            })
            .filter(Boolean);

          if (brakeAreas.length) {
            series.push({
              name: "Brake Feel Test",
              type: "line",
              data: [],
              markArea: {
                silent: true,
                data: brakeAreas,
              },
            });
          }

          // Add violation markers if available
          if (payload.violations && payload.violations.length > 0) {
            const violationData = samples.map((s, idx) => {
              const violation = payload.violations.find(v => v.index === idx);
              return violation ? s.speed : null;
            });

            series.push({
              name: 'Violations',
              type: 'scatter',
              data: violationData,
              symbolSize: 8,
              itemStyle: { color: '#ff0000' },
              z: 3,  // Draw on top of everything
            });
          }

          const legendEntries = [];
          if (hasPSR) legendEntries.push("MPS/PSR");
          legendEntries.push("Actual Speed");
          if (payload.violations && payload.violations.length > 0) {
            legendEntries.push("Violations");
          }
          if (brakeAreas.length) {
            legendEntries.push("Brake Feel Test");
          }

          chartInstance.setOption({
            title: {
              text: hasPSR ? 'Speed Profile with PSR/MPS Overlay' : 'Speed Profile',
              left: 'center',
              top: 5,
              textStyle: { fontSize: 14, fontWeight: 600, color: '#0b3d91' }
            },
            tooltip: {
              trigger: 'axis',
              formatter: function(params) {
                let tip = `<b>Distance: ${params[0].axisValue} km</b><br/>`;
                params.forEach(param => {
                  if (param.value !== null) {
                    const color = param.color;
                    tip += `<span style="display:inline-block;margin-right:5px;border-radius:50%;width:10px;height:10px;background-color:${color};"></span>`;
                    tip += `${param.seriesName}: ${param.value} km/h<br/>`;
                  }
                });
                return tip;
              }
            },
            legend: {
              data: legendEntries,
              top: 28,
              textStyle: { fontSize: 10 }
            },
            grid: { left: 50, right: 30, top: 65, bottom: 50 },
            xAxis: {
              type: 'category',
              data: distances,
              name: 'Cumulative Distance (km)',
              nameLocation: 'middle',
              nameGap: 30,
              axisLabel: { fontSize: 9, rotate: 45 }
            },
            yAxis: {
              type: 'value',
              name: 'Speed (km/h)',
              nameLocation: 'middle',
              nameGap: 35,
              axisLabel: { fontSize: 9 }
            },
            series: series
          });
          renderSegmentCharts(samples, payload.station_markers, brakeTests);
          renderPlatformEntryCharts(samples, payload.station_markers, payload.platform_entry_data);
          renderBrakeFeelChart(samples, brakeTests, payload.first_halt_index);
          renderTripSummary(payload.station_markers, brakeTests, samples);

        } catch (err) {
          console.error(err);
          alert("Unable to load chart data");
        }
      }

      const onFilesSelected = (files) => {
        if (!files || !files.length) {
          fileInfo.textContent = "No file selected yet.";
          return;
        }
        const file = files[0];
        fileInfo.textContent = `${file.name} • ${(file.size / 1024).toFixed(
          1
        )} KB`;
      };

      uploadZone.addEventListener("click", (e) => {
        // Only trigger if not clicking the input itself
        if (e.target !== fileInput) {
          fileInput.click();
        }
      });
      uploadZone.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadZone.classList.add("dragover");
      });
      uploadZone.addEventListener("dragleave", () =>
        uploadZone.classList.remove("dragover")
      );
      uploadZone.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadZone.classList.remove("dragover");
        onFilesSelected(e.dataTransfer.files);
      });
      fileInput.addEventListener("change", (e) =>
        onFilesSelected(e.target.files)
      );

      processBtn.addEventListener("click", async () => {
        processBtn.disabled = true;
        processBtn.textContent = "Processing...";

        try {
          // Upload file first
          const uploadResult = await uploadFile();

          if (uploadResult && uploadResult.success) {
            currentRunId = uploadResult.run_id;

            

            // Show success message
            const summary = uploadResult.summary;
            
            // 1. Show the Header
    document.getElementById("pdfHeader").style.display = "flex"; // Use flex to keep alignment

    // 2. Set "Date of Analysis" (Current Date)
    const today = new Date();
    // Formats to "26/12/2025" (Day/Month/Year)
    const dateStr = today.toLocaleDateString('en-GB', {
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric'
    });
    document.getElementById("headerAnalysisDate").textContent = dateStr;

     // --- 1. Show the Section ---
    document.getElementById("reportMetadata").style.display = "block";

    // --- 2. Get Input Values ---
    const trainNo = document.getElementById("trainNumber").value || "N/A";
    const staffText = document.getElementById("staffId").options[document.getElementById("staffId").selectedIndex].text;
    const fromStn = document.getElementById("fromStation").value || "?";
    const toStn = document.getElementById("toStation").value || "?";
    const analyst = document.getElementById("analysedBy").value || "Admin";
    const unitNo = document.getElementById("unitNumber").value || "-";
    
    // --- 3. Format Date of Working ---
    let workingDate = document.getElementById("dateOfWorking").value;
    if(workingDate) {
       // Convert YYYY-MM-DD to DD/MM/YYYY for display
       const d = new Date(workingDate);
       workingDate = d.toLocaleDateString('en-GB'); 
    } else {
       workingDate = "-";
    }

    // --- 4. Populate the Grid ---
    document.getElementById("metaDate").textContent = workingDate;
    document.getElementById("metaStaff").textContent = staffText;
    document.getElementById("metaRoute").textContent = `${fromStn} ➝ ${toStn}`;
    document.getElementById("metaUnit").textContent = unitNo;
    document.getElementById("metaAnalyst").textContent = analyst;

    // CLUBBING TRAIN NUMBER & TYPE
    // Assuming backend sends 'train_type' (e.g., 'Slow', 'Fast'). 
    // If not, default to empty string or 'Suburban'
    const typeFromDB = uploadResult.train_type || "Suburban"; 
    document.getElementById("metaTrainInfo").textContent = `${trainNo} / ${typeFromDB}`;

    // NOMINATED CLI FROM DB
    // Assuming backend sends 'nominated_cli'. 
    // You mentioned this is fetched from DB.
    document.getElementById("metaCli").textContent = uploadResult.nominated_cli || "Not Assigned";

    // METRICS FROM SUMMARY
    document.getElementById("metaDistance").textContent = (summary.total_distance || 0).toFixed(2) + " km";
    document.getElementById("metaMaxSpeed").textContent = (summary.max_speed || 0) + " km/h";
    
    // TIMESTAMPS
    if (uploadResult.start_time) document.getElementById("metaDepTime").textContent = uploadResult.start_time;
    if (uploadResult.end_time) document.getElementById("metaArrTime").textContent = uploadResult.end_time;
    if (uploadResult.duration) document.getElementById("metaRunTime").textContent = uploadResult.duration;
            let message = `✓ Upload successful!\n\n` +
              `Rows: ${uploadResult.rows_processed}\n` +
              `Max Speed: ${summary.max_speed} km/h\n` +
              `Avg Speed: ${summary.avg_speed.toFixed(1)} km/h\n` +
              `Total Distance: ${summary.total_distance.toFixed(2)} km\n`;

            // Add PSR/MPS info if available
            if (summary.psr_calculated) {
              message += `\n✓ PSR/MPS: Calculated\n`;
              message += `Train Type: ${uploadResult.train_type || 'unknown'}\n`;
              message += `Halts Detected: ${uploadResult.halts_detected || 0}\n`;

              if (uploadResult.violation_count > 0) {
                message += `\n⚠️ Violations Found: ${uploadResult.violation_count}\n`;
                const vsum = uploadResult.violations_summary;
                if (vsum.critical > 0) message += `  • Critical: ${vsum.critical}\n`;
                if (vsum.severe > 0) message += `  • Severe: ${vsum.severe}\n`;
                if (vsum.moderate > 0) message += `  • Moderate: ${vsum.moderate}\n`;
                if (vsum.minor > 0) message += `  • Minor: ${vsum.minor}\n`;
              }
            }

            alert(message);

            // Load chart data for this run
            await loadChartData(currentRunId);
          }
        } catch (err) {
          console.error(err);
          alert("Processing failed: " + err.message);
        } finally {
          processBtn.disabled = false;
          processBtn.textContent = "Process Run";
        }
      });

      clearBtn.addEventListener("click", () => {
        fileInput.value = "";
        fileInfo.textContent = "No file selected yet.";
        document.getElementById("staffId").selectedIndex = 0;
        document.getElementById("fromStation").selectedIndex = 0;
        document.getElementById("toStation").selectedIndex = 0;
        document.getElementById("trainNumber").value = "";
        document.getElementById("notes").value = "";
      });

      // Make chart responsive
      window.addEventListener("resize", () => {
        if (chart) {
          chart.resize();
        }
        if (brakeFeelChart) {
          brakeFeelChart.resize();
        }
        segmentCharts.forEach((segChart) => segChart.resize());
        platformEntryCharts.forEach((peChart) => peChart.resize());
      });
    </script>
  </body>
</html>
